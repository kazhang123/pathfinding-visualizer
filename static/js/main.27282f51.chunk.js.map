{"version":3,"sources":["components/navbar.jsx","components/legend.jsx","components/node.jsx","algorithms/PriorityQueue.js","algorithms/dijkstras.js","algorithms/Queue.js","algorithms/bfs.js","algorithms/Stack.js","algorithms/dfs.js","algorithms/aStar.js","PathfindingVisualizer.js","index.js"],"names":["NavBar","Navbar","collapseOnSelect","expand","bg","variant","Brand","href","Toggle","aria-controls","Collapse","id","Nav","className","NavDropdown","title","Item","onSelect","props","setAlgorithm","Button","onClick","this","onVisualize","selectedAlgorithm","onClearPath","onClearWalls","onReset","Component","Legend","width","height","viewBox","class","fill","xmlns","fill-rule","d","key","legend","timeTaken","Node","classes","node","isStart","isEnd","isVisited","isWall","isPath","isAnimating","startEndNode","col","row","onMouseDown","onMouseEnter","onMouseUp","getClasses","PriorityQueue","scoreFunction","heap","value","push","heapifyUp","length","min","pop","heapifyDown","idx","Math","floor","leftChild","currIdx","leftIdx","rightIdx","rightChild","hasAChild","minChildIdx","minChild","childScore","swap","parentIdx","parent","idxA","idxB","temp","dijkstras","graph","startNode","endNode","visited","pq","distance","isEmpty","currNode","neighbours","getUnvisitedNeighbours","neighbour","predecessor","filter","n","Queue","elems","first","size","elem","front","splice","console","log","slice","bfs","q","enqueue","dequeue","Stack","dfs","stack","aStar","openSet","f","h","abs","g","PathfindingVisualizer","state","nodes","start","x","y","end","mouseIsPressed","startIsPressed","endIsPressed","toFixed","algorithmMessage","handleMouseDown","setState","toggleWall","handleMouseEnter","changeStartNode","changeEndNode","handleMouseUp","setSelectedAlgorithm","algorithm","handleVisualize","visualize","alert","handleReset","getInitialGraph","clearWalls","resetNodesToUnvisited","Infinity","map","newNode","startTime","performance","now","visitedNodes","time","i","setTimeout","shortestPath","path","reverse","getShortestPath","animatePath","document","getElementById","Fragment","Date","colIdx","rowIdx","currCol","ReactDOM","render"],"mappings":"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","file":"static/js/main.27282f51.chunk.js","sourcesContent":["import React, { Component } from \"react\";\nimport { Navbar, Nav, NavDropdown, Button } from \"react-bootstrap\";\n\nexport const DIJKSTRAS_LABEL = \"Dijkstra's\";\nexport const BFS_LABEL = \"BFS\";\nexport const DFS_LABEL = \"DFS\";\nexport const ASTAR_LABEL = \"A*\";\n\nclass NavBar extends Component {\n  render() {\n    return (\n      <Navbar collapseOnSelect expand=\"lg\" bg=\"dark\" variant=\"dark\">\n        <Navbar.Brand href=\"#home\">Pathfinding Visualizer</Navbar.Brand>\n        <Navbar.Toggle aria-controls=\"responsive-navbar-nav\" />\n        <Navbar.Collapse id=\"responsive-navbar-nav\">\n          <Nav className=\"mr-auto\">\n            <NavDropdown title=\"Algorithms\" id=\"collasible-nav-dropdown\">\n              <NavDropdown.Item\n                href=\"#action/3.1\"\n                onSelect={() => this.props.setAlgorithm(DIJKSTRAS_LABEL)}\n              >\n                Dijkstra's\n              </NavDropdown.Item>\n              <NavDropdown.Item\n                href=\"#action/3.2\"\n                onSelect={() => this.props.setAlgorithm(BFS_LABEL)}\n              >\n                Breadth First Search\n              </NavDropdown.Item>\n              <NavDropdown.Item\n                href=\"#action/3.3\"\n                onSelect={() => this.props.setAlgorithm(DFS_LABEL)}\n              >\n                Depth First Search\n              </NavDropdown.Item>\n              <NavDropdown.Item\n                href=\"#action/3.4\"\n                onSelect={() => this.props.setAlgorithm(ASTAR_LABEL)}\n              >\n                A*\n              </NavDropdown.Item>\n            </NavDropdown>\n            <span>\n              <Button variant=\"info\" onClick={this.props.onVisualize}>\n                {`Visualize ${this.props.selectedAlgorithm}`}\n              </Button>{\" \"}\n            </span>\n            <Button variant=\"dark\" onClick={this.props.onClearPath}>\n              Clear Path\n            </Button>{\" \"}\n            <Button variant=\"dark\" onClick={this.props.onClearWalls}>\n              Clear Walls\n            </Button>{\" \"}\n            <Button variant=\"dark\" onClick={this.props.onReset}>\n              Reset\n            </Button>\n          </Nav>\n        </Navbar.Collapse>\n      </Navbar>\n    );\n  }\n}\n\nexport default NavBar;\n","import React, { Component } from \"react\";\nimport \"./legend.css\";\n\nclass Legend extends Component {\n  render() {\n    return (\n      <div className=\"legend\">\n        <span className=\"legend-item block green\"></span>\n        <span className=\"legend-item\">Visited nodes</span>\n        <span className=\"legend-item block yellow\"></span>\n        <span className=\"legend-item\">Path</span>\n        <span>\n          <span id=\"startSymbol\" className=\"legend-item\"></span>\n          <span className=\"legend-item\">Start node</span>\n        </span>\n        <span>\n          <span id=\"endSymbol\" className=\"legend-item\"></span>\n          <span className=\"legend-item\">End node</span>\n        </span>\n\n        <span className=\"legend-item time\">\n          <svg\n            width=\"1em\"\n            height=\"1em\"\n            viewBox=\"0 0 16 16\"\n            class=\"bi bi-clock m-2\"\n            fill=\"currentColor\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n          >\n            <path\n              fill-rule=\"evenodd\"\n              d=\"M8 15A7 7 0 1 0 8 1a7 7 0 0 0 0 14zm8-7A8 8 0 1 1 0 8a8 8 0 0 1 16 0z\"\n            />\n            <path\n              fill-rule=\"evenodd\"\n              d=\"M7.5 3a.5.5 0 0 1 .5.5v5.21l3.248 1.856a.5.5 0 0 1-.496.868l-3.5-2A.5.5 0 0 1 7 9V3.5a.5.5 0 0 1 .5-.5z\"\n            />\n          </svg>\n          <span\n            className=\"legend-item time\"\n            key={this.props.legend.timeTaken}\n          >{`${this.props.legend.timeTaken} ms to find path`}</span>\n        </span>\n      </div>\n    );\n  }\n}\n\nexport default Legend;\n","import React, { Component } from \"react\";\nimport \"./node.css\";\n\nclass Node extends Component {\n  getClasses() {\n    let classes = \"node \";\n    const {\n      isStart,\n      isEnd,\n      isVisited,\n      isWall,\n      isPath,\n      isAnimating,\n    } = this.props.node;\n\n    classes += isStart\n      ? \"start\"\n      : isEnd\n      ? \"end\"\n      : isWall\n      ? \"wall\"\n      : // : isVisited\n        // ? \"visited\"\n        // : isPath\n        // ? \"path\"\n        \"\";\n\n    // if not currently animating nodes, keep nodes stagnant colours\n    if (!isAnimating) {\n      if (isPath) {\n        classes = \"path \" + classes;\n      } else if (isVisited) {\n        classes = \"visited \" + classes;\n      }\n    }\n\n    return classes;\n  }\n\n  render() {\n    const { col, row, isStart, isEnd } = this.props.node;\n\n    // if node is start/end, render specific symbol on top of the node\n    let startEndNode;\n\n    if (isStart) {\n      startEndNode = (\n        <div\n          className=\"startWrap\"\n          onMouseDown={() => this.props.onMouseDown(col, row)}\n          onMouseEnter={() => this.props.onMouseEnter(col, row)}\n          onMouseUp={() => this.props.onMouseUp()}\n        ></div>\n      );\n    } else if (isEnd) {\n      startEndNode = (\n        <div\n          className=\"endWrap\"\n          onMouseDown={() => this.props.onMouseDown(col, row)}\n          onMouseEnter={() => this.props.onMouseEnter(col, row)}\n          onMouseUp={() => this.props.onMouseUp()}\n        ></div>\n      );\n    }\n\n    return (\n      <div className=\"wrap\">\n        {startEndNode}\n        <div\n          onMouseDown={() => this.props.onMouseDown(col, row)}\n          onMouseEnter={() => this.props.onMouseEnter(col, row)}\n          onMouseUp={() => this.props.onMouseUp()}\n          className={this.getClasses()}\n          id={`node ${col} ${row}`}\n        ></div>\n      </div>\n    );\n  }\n}\n\nexport default Node;\n","export default class PriorityQueue {\n  constructor(scoreFunction) {\n    this.heap = [null];\n    this.scoreFunction = scoreFunction;\n  }\n\n  push(value) {\n    this.heap.push(value);\n    this.heapifyUp(this.heap.length - 1);\n  }\n\n  pop() {\n    const min = this.heap[1];\n    this.heap[1] = this.heap[this.heap.length - 1];\n    this.heap.pop();\n    this.heapifyDown(1);\n    return min;\n  }\n\n  isEmpty() {\n    return this.heap.length === 1;\n  }\n\n  peek() {\n    const min = this.heap[1];\n    return min;\n  }\n\n  leftChild(idx) {\n    return 2 * idx;\n  }\n\n  rightChild(idx) {\n    return 2 * idx + 1;\n  }\n\n  parent(idx) {\n    return Math.floor(idx / 2);\n  }\n\n  hasAChild(idx) {\n    return this.leftChild(idx) < this.heap.length;\n  }\n\n  /**\n   * returns the child of the current index with the lowest score\n   * assume function will be called only if currIdx has a child\n   * @param {*} currIdx\n   */\n  minChild(currIdx) {\n    const leftIdx = this.leftChild(currIdx);\n    const rightIdx = this.rightChild(currIdx);\n\n    // if no right child, then return left child\n    if (rightIdx >= this.heap.length) {\n      return leftIdx;\n    }\n\n    const leftScore = this.scoreFunction(this.heap[leftIdx]);\n    const rightScore = this.scoreFunction(this.heap[rightIdx]);\n\n    if (leftScore < rightScore) {\n      return leftIdx;\n    }\n\n    return rightIdx;\n  }\n\n  heapifyDown(currIdx) {\n    if (this.hasAChild(currIdx)) {\n      const minChildIdx = this.minChild(currIdx);\n\n      const childScore = this.scoreFunction(this.heap[minChildIdx]);\n      const currScore = this.scoreFunction(this.heap[currIdx]);\n\n      if (currScore > childScore) {\n        this.swap(currIdx, minChildIdx);\n        this.heapifyDown(minChildIdx);\n      }\n    }\n  }\n\n  heapifyUp(currIdx) {\n    if (currIdx === 1) {\n      return;\n    }\n\n    const parentIdx = this.parent(currIdx);\n\n    const currScore = this.scoreFunction(this.heap[currIdx]);\n    const parentScore = this.scoreFunction(this.heap[parentIdx]);\n\n    if (currScore < parentScore) {\n      this.swap(currIdx, parentIdx);\n      this.heapifyUp(parentIdx);\n    }\n  }\n\n  swap(idxA, idxB) {\n    let temp = this.heap[idxA];\n    this.heap[idxA] = this.heap[idxB];\n    this.heap[idxB] = temp;\n  }\n}\n","import PriorityQueue from \"./PriorityQueue\";\n\nexport function dijkstras(graph, startNode, endNode) {\n  // track visited nodes in order\n  let visited = [];\n\n  let pq = new PriorityQueue(function (node) {\n    return node.distance;\n  });\n\n  // initialize source\n  startNode.distance = 0;\n  pq.push(startNode);\n  // start at source node\n\n  while (!pq.isEmpty()) {\n    let currNode = pq.pop();\n    // console.log(currNode);\n\n    const { col, row } = currNode;\n\n    currNode.isVisited = true;\n    visited.push(currNode);\n    // if current node is end node, we are done searching\n    if (currNode === endNode) {\n      return visited;\n    }\n\n    // for each unvisited neighbour:\n    let neighbours = getUnvisitedNeighbours(graph, currNode);\n    for (let neighbour of neighbours) {\n      // update distance from start node and predecessor\n      if (currNode.distance + 1 < neighbour.distance) {\n        neighbour.distance = currNode.distance + 1;\n        neighbour.predecessor = currNode;\n        pq.push(neighbour);\n      }\n    }\n  }\n\n  return visited;\n}\n\n/*\nreturns shortest path from startNode to endNode\n*/\nexport function getShortestPath(endNode) {\n  const path = [];\n\n  // If there is no path to the endNode i.e the endNode does not have a predecessor\n  if (endNode.predecessor === null) {\n    return [];\n  }\n\n  let currNode = endNode;\n  while (currNode !== null) {\n    currNode.isPath = true;\n    path.push(currNode);\n    currNode = currNode.predecessor;\n  }\n\n  return path.reverse();\n}\n\n/*\nreturns unvisited, non-wall neighbours (N, E, S, W) of given node \n*/\nexport function getUnvisitedNeighbours(graph, node) {\n  const neighbours = [];\n  const { col, row } = node;\n  if (row > 0) neighbours.push(graph[col][row - 1]);\n  if (col < graph.length - 1) neighbours.push(graph[col + 1][row]);\n  if (row < graph[0].length - 1) neighbours.push(graph[col][row + 1]);\n  if (col > 0) neighbours.push(graph[col - 1][row]);\n\n  return neighbours.filter((n) => !n.isVisited && !n.isWall);\n}\n","export default class Queue {\n  constructor() {\n    this.elems = [];\n    this.first = 0; // index of first element in array\n    this.size = 0; // number of items in array\n  }\n\n  /**\n   * pushes given object to end of queue\n   * @param {*} elem\n   */\n  enqueue(elem) {\n    this.elems.push(elem);\n    this.size++;\n  }\n\n  /**\n   * returns and removes object at front of queue\n   * resizes array downward when elements can fit into the first\n   * 0...k-1 indices of the array to achieve O(1) amortized runtime\n   *\n   * assume function will not be called on an empty queue\n   */\n  dequeue() {\n    const front = this.elems[this.first];\n    this.elems[this.first] = null;\n    this.first++;\n    this.size--;\n\n    if (!this.isEmpty() && this.size === this.first) {\n      // const newArray = this.elems.slice(this.first);\n      // let newArray = [];\n      // for (let i = 0; i < this.size; i++) {\n      //   newArray.push(this.elems[i + this.first]);\n      // }\n\n      this.elems.splice(0, this.first);\n\n      // this.elems = newArray;\n      this.first = 0;\n    }\n\n    return front;\n  }\n\n  /**\n   * returns whether queue is empty\n   */\n  isEmpty() {\n    return this.size === 0;\n  }\n\n  /**\n   * returns object at front of queue without removing it\n   */\n  front() {\n    return this.elems[this.first];\n  }\n\n  peek() {\n    console.log(this.elems.slice());\n    console.log(this.first);\n    console.log(this.size);\n  }\n}\n","import Queue from \"./Queue\";\nimport { getUnvisitedNeighbours } from \"./dijkstras\";\n\nexport function bfs(graph, startNode, endNode) {\n  const q = new Queue();\n  const visited = [];\n\n  q.enqueue(startNode);\n  visited.push(startNode);\n  startNode.isVisited = true;\n\n  while (!q.isEmpty()) {\n    let currNode = q.dequeue();\n\n    let neighbours = getUnvisitedNeighbours(graph, currNode);\n    for (let neighbour of neighbours) {\n      neighbour.isVisited = true;\n      visited.push(neighbour);\n      neighbour.predecessor = currNode;\n\n      if (neighbour === endNode) {\n        return visited;\n      }\n\n      q.enqueue(neighbour);\n    }\n  }\n\n  return visited;\n}\n","export default class Stack {\n  constructor() {\n    this.elems = [];\n  }\n\n  push(elem) {\n    this.elems.push(elem);\n  }\n\n  pop() {\n    return this.elems.pop();\n  }\n\n  isEmpty() {\n    return this.elems.length === 0;\n  }\n\n  peek() {\n    return this.elems[this.elems.length - 1];\n  }\n}\n","import Stack from \"./Stack\";\nimport { getUnvisitedNeighbours } from \"./dijkstras\";\n\nexport function dfs(graph, startNode, endNode) {\n  const stack = new Stack();\n  const visited = [];\n\n  stack.push(startNode);\n  visited.push(startNode);\n  startNode.isVisited = true;\n\n  while (!stack.isEmpty()) {\n    let currNode = stack.pop();\n\n    let neighbours = getUnvisitedNeighbours(graph, currNode);\n    for (let neighbour of neighbours) {\n      neighbour.isVisited = true;\n      visited.push(neighbour);\n      neighbour.predecessor = currNode;\n\n      if (neighbour === endNode) {\n        return visited;\n      }\n\n      stack.push(neighbour);\n    }\n  }\n\n  return visited;\n}\n","import PriorityQueue from \"./PriorityQueue\";\nimport { getUnvisitedNeighbours } from \"./dijkstras\";\n\nexport function aStar(graph, startNode, endNode) {\n  const openSet = new PriorityQueue(function (node) {\n    return node.f;\n  });\n\n  const visited = []; // closed set\n\n  // initialize open set\n  startNode.f = 0;\n  startNode.distance = 0;\n  openSet.push(startNode);\n\n  while (!openSet.isEmpty()) {\n    // find node with least f on open set\n    let currNode = openSet.pop();\n\n    currNode.isVisited = true;\n    visited.push(currNode);\n\n    if (currNode === endNode) {\n      return visited;\n    }\n\n    let neighbours = getUnvisitedNeighbours(graph, currNode);\n    for (let neighbour of neighbours) {\n      if (currNode.distance + 1 < neighbour.distance) {\n        neighbour.predecessor = currNode;\n        neighbour.distance = currNode.distance + 1;\n\n        // calculate manhattan distance heuristic for neighbour\n        let h =\n          Math.abs(neighbour.col - endNode.col) +\n          Math.abs(neighbour.row - endNode.row);\n        let g = neighbour.distance;\n        neighbour.f = g + h;\n\n        openSet.push(neighbour);\n      }\n    }\n  }\n\n  return visited;\n}\n","import React, { Component } from \"react\";\nimport NavBar from \"./components/navbar\";\nimport {\n  DIJKSTRAS_LABEL,\n  BFS_LABEL,\n  DFS_LABEL,\n  ASTAR_LABEL,\n} from \"./components/navbar\";\nimport Legend from \"./components/legend\";\nimport Node from \"./components/node.jsx\";\nimport \"./PathfindingVisualizer.css\";\nimport { dijkstras, getShortestPath } from \"./algorithms/dijkstras\";\nimport { bfs } from \"./algorithms/bfs\";\nimport { dfs } from \"./algorithms/dfs\";\nimport { aStar } from \"./algorithms/aStar\";\n\nconst START_NODE_X = 12;\nconst START_NODE_Y = 10;\nconst END_NODE_X = 30;\nconst END_NODE_Y = 10;\nconst NUM_COLS = 43;\nconst NUM_ROWS = 21;\nconst TIME = 0;\n\nclass PathfindingVisualizer extends Component {\n  state = {\n    nodes: [],\n    start: { x: START_NODE_X, y: START_NODE_Y },\n    end: { x: END_NODE_X, y: END_NODE_Y },\n    mouseIsPressed: false,\n    startIsPressed: false,\n    endIsPressed: false,\n    selectedAlgorithm: \"\",\n    legend: {\n      timeTaken: TIME.toFixed(3),\n      algorithmMessage: \"\",\n    },\n    isAnimating: false,\n  };\n\n  componentDidMount() {\n    const nodes = this.getInitialGraph();\n    this.setState({ nodes });\n  }\n\n  /**\n   * animates the given visited nodes in order\n   * and the shortest path in order after the visited nodes\n   */\n  // visualize = (visitedNodes, shortestPath) => {\n  //   this.resetNodesToUnvisited();\n  //   const startTime = performance.now();\n\n  //   // for each visited node:\n  //   // one extra iteration to animate path\n  //   for (let i = 0; i <= visitedNodes.length; i++) {\n  //     // if on last iteration, animate path\n  //     // timeout proportional to iteration number so path animates after visited nodes\n  //     if (i === visitedNodes.length) {\n  //       setTimeout(() => {\n  //         // get time allotted for searching animation to finish\n  //         console.log(this.getTimeAlotted(startTime));\n  //         const time = this.getTimeAlotted(startTime);\n  //         // this.setState({ legend: { timeTaken: time } });\n\n  //         this.animatePath(shortestPath);\n  //       }, 15 * i);\n\n  //       return;\n  //     }\n\n  //     let currNode = visitedNodes[i];\n  //     const { col, row } = currNode;\n  //     // animate each node to change colour one after another\n  //     // timeout based on position in list so that\n  //     // each node should only changes colour after the previously visited one has changed colour\n  //     setTimeout(() => {\n  //       document.getElementById(`node ${col} ${row}`).className += \" visited\";\n  //     }, 15 * i);\n  //   }\n  // };\n\n  /**\n   * animates traversal of given algorithm on current graph state\n   * @param {*} algorithm algorithm to visualize\n   */\n  visualize(algorithm) {\n    this.resetNodesToUnvisited();\n\n    // deep copy of the state's nodes\n    const graph = this.state.nodes.map((col) => {\n      return col.map((node) => {\n        let newNode = {};\n        for (let key in node) {\n          newNode[key] = node[key];\n        }\n        return newNode;\n      });\n    });\n\n    const { start, end } = this.state;\n    const startNode = graph[start.x][start.y];\n    const endNode = graph[end.x][end.y];\n    const startTime = performance.now();\n\n    const visitedNodes = algorithm(graph, startNode, endNode);\n\n    // get time allotted for searching animation to finish\n    const endTime = performance.now();\n    const time = (endTime - startTime).toFixed(3);\n\n    // start animation of traversal\n    this.setState({ isAnimating: true });\n    // for each visited node:\n    // one extra iteration to animate path\n    for (let i = 0; i <= visitedNodes.length; i++) {\n      // if on last iteration, animate path\n      // timeout proportional to iteration number so path animates after visited nodes\n      if (i === visitedNodes.length) {\n        setTimeout(() => {\n          const shortestPath = getShortestPath(endNode);\n          this.animatePath(shortestPath);\n\n          setTimeout(() => {\n            this.setState({ nodes: graph, isAnimating: false });\n\n            this.setState({ legend: { timeTaken: time } });\n          }, 30 * shortestPath.length + 1200); /** delay until last iteration of path animation\n                                                plus amount of seconds to animate path node */\n        }, 15 * i + 500);\n\n        return;\n      }\n\n      let currNode = visitedNodes[i];\n      const { col, row } = currNode;\n      // animate each node to change colour one after another\n      // timeout based on position in list so that\n      // each node should only changes colour after the previously visited one has changed colour\n      setTimeout(() => {\n        document.getElementById(`node ${col} ${row}`).className +=\n          \" visited-animation\";\n      }, 15 * i);\n    }\n  }\n\n  /**\n   * animates the given shortest path nodes in order\n   * @param {*} shortestPath\n   */\n  animatePath(shortestPath) {\n    for (let i = 0; i < shortestPath.length; i++) {\n      let currNode = shortestPath[i];\n      const { col, row } = currNode;\n      setTimeout(() => {\n        document.getElementById(`node ${col} ${row}`).className +=\n          \" path-animation\";\n      }, 30 * i);\n    }\n  }\n\n  // /**\n  //  * returns time allotted since start time in s\n  //  * @param {*} startTime\n  //  */\n  // getTimeAlotted(startTime) {\n  //   const endTime = performance.now();\n  //   const time = endTime - startTime;\n  //   return time.toFixed(3);\n  // }\n\n  handleMouseDown = (x, y) => {\n    const graph = [...this.state.nodes];\n    const currNode = graph[x][y];\n    if (!currNode.isStart && !currNode.isEnd) {\n      this.toggleWall(currNode, graph);\n      this.setState({ mouseIsPressed: true });\n    } else {\n      if (currNode.isStart) {\n        this.setState({ mouseIsPressed: true, startIsPressed: true });\n      } else {\n        this.setState({ mouseIsPressed: true, endIsPressed: true });\n      }\n    }\n  };\n\n  handleMouseEnter = (x, y) => {\n    if (!this.state.mouseIsPressed) {\n      return;\n    }\n\n    const graph = [...this.state.nodes];\n    const currNode = graph[x][y];\n\n    if (this.state.startIsPressed) {\n      this.changeStartNode(currNode, graph);\n      return;\n    } else if (this.state.endIsPressed) {\n      this.changeEndNode(currNode, graph);\n      return;\n    }\n\n    if (!currNode.isStart && !currNode.isEnd) {\n      this.toggleWall(currNode, graph);\n    }\n  };\n\n  handleMouseUp = () => {\n    // make sure that where start and end node are placed is not ON a wall\n    const nodes = [...this.state.nodes];\n    const { start, end } = this.state;\n    nodes[start.x][start.y].isWall = false;\n    nodes[end.x][end.y].isWall = false;\n\n    this.setState({\n      nodes,\n      mouseIsPressed: false,\n      startIsPressed: false,\n      endIsPressed: false,\n    });\n  };\n\n  setSelectedAlgorithm = (algorithm) => {\n    this.setState({ selectedAlgorithm: algorithm });\n  };\n\n  // handleVisualize = () => {\n  //   const { selectedAlgorithm } = this.state;\n  //   const graph = [...this.state.nodes];\n  //   const { start, end } = this.state;\n  //   const startNode = graph[start.x][start.y];\n  //   const endNode = graph[end.x][end.y];\n\n  //   let visitedNodes = null;\n\n  //   switch (selectedAlgorithm) {\n  //     case \"Dijkstra's\":\n  //       visitedNodes = dijkstras(graph, startNode, endNode);\n  //       break;\n  //     case \"BFS\":\n  //       visitedNodes = bfs(graph, startNode, endNode);\n  //       break;\n  //     case \"DFS\":\n  //       visitedNodes = dfs(graph, startNode, endNode);\n  //       break;\n  //     case \"A*\":\n  //       visitedNodes = aStar(graph, startNode, endNode);\n  //       break;\n  //     default:\n  //       this.setState({ popoverOpen: true });\n  //       return;\n  //   }\n  //   const shortestPath = getShortestPath(endNode);\n  //   this.visualize(visitedNodes, shortestPath);\n  // };\n\n  handleVisualize = () => {\n    const { selectedAlgorithm } = this.state;\n\n    switch (selectedAlgorithm) {\n      case DIJKSTRAS_LABEL:\n        this.visualize(dijkstras);\n        break;\n      case BFS_LABEL:\n        this.visualize(bfs);\n        break;\n      case DFS_LABEL:\n        this.visualize(dfs);\n        break;\n      case ASTAR_LABEL:\n        this.visualize(aStar);\n        break;\n      default:\n        alert(\"Select an algorithm to visualize!\");\n        return;\n    }\n  };\n\n  /**\n   * resets graph to the intial graph\n   */\n  handleReset = () => {\n    const nodes = this.getInitialGraph();\n    this.setState({\n      nodes,\n      start: { x: START_NODE_X, y: START_NODE_Y },\n      end: { x: END_NODE_X, y: END_NODE_Y },\n    });\n  };\n\n  /**\n   * clears all walls from graph without moving start and end nodes\n   */\n  clearWalls = () => {\n    const graph = [...this.state.nodes];\n    for (let x = 0; x < NUM_COLS; x++) {\n      for (let y = 0; y < NUM_ROWS; y++) {\n        let node = graph[x][y];\n        node.isWall = false;\n      }\n    }\n\n    this.setState({ nodes: graph });\n  };\n\n  render() {\n    return (\n      <React.Fragment>\n        <NavBar\n          setAlgorithm={this.setSelectedAlgorithm}\n          selectedAlgorithm={this.state.selectedAlgorithm}\n          onVisualize={this.handleVisualize}\n          onReset={this.handleReset}\n          onClearPath={this.resetNodesToUnvisited}\n          onClearWalls={this.clearWalls}\n        />\n        <Legend legend={this.state.legend} />\n        <div key={new Date()} className=\"grid\">\n          {this.state.nodes.map((col, colIdx) => {\n            return (\n              <div key={colIdx}>\n                {col.map((node, rowIdx) => (\n                  <Node\n                    key={rowIdx}\n                    onMouseDown={this.handleMouseDown}\n                    onMouseEnter={this.handleMouseEnter}\n                    onMouseUp={this.handleMouseUp}\n                    isAnimating={this.state.isAnimating}\n                    node={node}\n                  />\n                ))}\n              </div>\n            );\n          })}\n        </div>\n      </React.Fragment>\n    );\n  }\n\n  /**\n   * \ttoggles the given node at x,y on the graph as/not as a wall\n   * @param {*} currNode\n   * @param {*} graph\n   */\n  toggleWall(currNode, graph) {\n    const newNode = {\n      ...currNode,\n      isWall: !currNode.isWall,\n    };\n\n    graph[currNode.col][currNode.row] = newNode;\n    this.setState({ nodes: graph });\n  }\n\n  /**\n   * sets given node as the end node\n   * @param {*} currNode\n   * @param {*} graph\n   */\n  changeEndNode(currNode, graph) {\n    const { col, row } = currNode;\n    const { x, y } = this.state.end;\n    graph[x][y].isEnd = false;\n    currNode.isEnd = true;\n    // currNode.isWall = false;\n    this.setState({ nodes: graph, end: { x: col, y: row } });\n  }\n\n  /**\n   * sets given node as the start node\n   * @param {*} currNode\n   * @param {*} graph\n   */\n  changeStartNode(currNode, graph) {\n    const { col, row } = currNode;\n    const { x, y } = this.state.start;\n    graph[x][y].isStart = false;\n    currNode.isStart = true;\n    // currNode.isWall = false;\n    this.setState({ nodes: graph, start: { x: col, y: row } });\n  }\n\n  /**\n   * resets state's nodes to before dijkstra's was called\n   */\n  resetNodesToUnvisited = () => {\n    const graph = [...this.state.nodes];\n    for (let x = 0; x < NUM_COLS; x++) {\n      for (let y = 0; y < NUM_ROWS; y++) {\n        let node = graph[x][y];\n        node.isVisited = false;\n        node.isPath = false;\n        node.distance = Infinity;\n        node.predecessor = null;\n      }\n    }\n\n    this.setState({ nodes: graph });\n  };\n\n  /**\n   * returns initial graph with no walls toggled or visited nodes\n   */\n  getInitialGraph() {\n    const nodes = [];\n\n    for (let col = 0; col < NUM_COLS; col++) {\n      const currCol = [];\n      for (let row = 0; row < NUM_ROWS; row++) {\n        const currNode = {\n          col,\n          row,\n          isStart: col === START_NODE_X && row === START_NODE_Y,\n          isEnd: col === END_NODE_X && row === END_NODE_Y,\n          isVisited: false,\n          isWall: false,\n          isPath: false,\n          distance: Infinity,\n          f: Infinity,\n          predecessor: null,\n        };\n        currCol.push(currNode);\n      }\n      nodes.push(currCol);\n    }\n    return nodes;\n  }\n}\n\nexport default PathfindingVisualizer;\n","import \"bootstrap/dist/css/bootstrap.min.css\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport PathfindingVisualizer from \"./PathfindingVisualizer\";\n\nReactDOM.render(<PathfindingVisualizer />, document.getElementById(\"root\"));\n"],"sourceRoot":""}