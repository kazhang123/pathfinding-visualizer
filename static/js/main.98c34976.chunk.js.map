{"version":3,"sources":["components/navbar.jsx","components/legend.jsx","components/node.jsx","algorithms/PriorityQueue.js","algorithms/dijkstras.js","algorithms/Queue.js","algorithms/bfs.js","algorithms/Stack.js","algorithms/dfs.js","algorithms/aStar.js","PathfindingVisualizer.js","index.js"],"names":["NavBar","Navbar","collapseOnSelect","expand","bg","variant","Brand","href","Toggle","aria-controls","Collapse","id","Nav","className","NavDropdown","title","Item","onSelect","props","setAlgorithm","Button","onClick","this","onVisualize","selectedAlgorithm","onClearPath","onClearWalls","onReset","Component","Legend","width","height","viewBox","class","fill","xmlns","style","fill-rule","d","key","legend","timeTaken","Node","classes","node","isStart","isEnd","isVisited","isWall","isPath","isAnimating","startEndNode","col","row","onMouseDown","onMouseEnter","onMouseUp","display","cursor","position","getClasses","PriorityQueue","scoreFunction","heap","value","push","heapifyUp","length","min","pop","heapifyDown","idx","Math","floor","leftChild","currIdx","leftIdx","rightIdx","rightChild","hasAChild","minChildIdx","minChild","childScore","swap","parentIdx","parent","idxA","idxB","temp","dijkstras","graph","startNode","endNode","visited","pq","distance","isEmpty","currNode","neighbours","getUnvisitedNeighbours","neighbour","predecessor","filter","n","Queue","elems","first","size","elem","front","splice","console","log","slice","bfs","q","enqueue","dequeue","Stack","dfs","stack","aStar","openSet","f","h","abs","g","PathfindingVisualizer","state","nodes","start","x","y","end","mouseIsPressed","startIsPressed","endIsPressed","toFixed","algorithmMessage","handleMouseDown","setState","toggleWall","handleMouseEnter","changeStartNode","changeEndNode","handleMouseUp","setSelectedAlgorithm","algorithm","handleVisualize","visualize","alert","handleReset","getInitialGraph","clearWalls","resetNodesToUnvisited","Infinity","map","newNode","startTime","performance","now","visitedNodes","time","i","setTimeout","shortestPath","path","reverse","getShortestPath","animatePath","document","getElementById","Fragment","Date","colIdx","rowIdx","currCol","ReactDOM","render"],"mappings":"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","file":"static/js/main.98c34976.chunk.js","sourcesContent":["import React, { Component } from \"react\";\nimport { Navbar, Nav, NavDropdown, Button } from \"react-bootstrap\";\n\nexport const DIJKSTRAS_LABEL = \"Dijkstra's\";\nexport const BFS_LABEL = \"BFS\";\nexport const DFS_LABEL = \"DFS\";\nexport const ASTAR_LABEL = \"A*\";\n\nclass NavBar extends Component {\n  render() {\n    return (\n      <Navbar collapseOnSelect expand=\"lg\" bg=\"light\" variant=\"light\">\n        <Navbar.Brand href=\"#home\">Pathfinding Visualizer</Navbar.Brand>\n        <Navbar.Toggle aria-controls=\"responsive-navbar-nav\" />\n        <Navbar.Collapse id=\"responsive-navbar-nav\">\n          <Nav className=\"mr-auto\">\n            <NavDropdown title=\"Algorithms\" id=\"collasible-nav-dropdown\">\n              <NavDropdown.Item\n                href=\"#action/3.1\"\n                onSelect={() => this.props.setAlgorithm(DIJKSTRAS_LABEL)}\n              >\n                Dijkstra's\n              </NavDropdown.Item>\n              <NavDropdown.Item\n                href=\"#action/3.2\"\n                onSelect={() => this.props.setAlgorithm(BFS_LABEL)}\n              >\n                Breadth First Search\n              </NavDropdown.Item>\n              <NavDropdown.Item\n                href=\"#action/3.3\"\n                onSelect={() => this.props.setAlgorithm(DFS_LABEL)}\n              >\n                Depth First Search\n              </NavDropdown.Item>\n              <NavDropdown.Item\n                href=\"#action/3.4\"\n                onSelect={() => this.props.setAlgorithm(ASTAR_LABEL)}\n              >\n                A*\n              </NavDropdown.Item>\n            </NavDropdown>\n            <span>\n              <Button variant=\"info\" onClick={this.props.onVisualize}>\n                {`Visualize ${this.props.selectedAlgorithm}`}\n              </Button>{\" \"}\n            </span>\n            <Button variant=\"light\" onClick={this.props.onClearPath}>\n              Clear Path\n            </Button>{\" \"}\n            <Button variant=\"light\" onClick={this.props.onClearWalls}>\n              Clear Walls\n            </Button>{\" \"}\n            <Button variant=\"light\" onClick={this.props.onReset}>\n              Reset\n            </Button>\n          </Nav>\n        </Navbar.Collapse>\n      </Navbar>\n    );\n  }\n}\n\nexport default NavBar;\n","import React, { Component } from \"react\";\nimport \"./legend.css\";\n\nclass Legend extends Component {\n  render() {\n    return (\n      <div className=\"legend\">\n        <span className=\"legend-item block black\"></span>\n        <span className=\"legend-item\">Wall</span>\n        <span className=\"legend-item block green\"></span>\n        <span className=\"legend-item\">Visited node</span>\n        <span className=\"legend-item block yellow\"></span>\n        <span className=\"legend-item\">Path</span>\n        <span>\n          <span id=\"startSymbol\" className=\"legend-item\"></span>\n          <span className=\"legend-item\">Start node</span>\n        </span>\n        <span>\n          <svg\n            width=\"2em\"\n            height=\"2em\"\n            viewBox=\"0 0 16 16\"\n            class=\"bi bi-asterisk ml-2\"\n            fill=\"currentColor\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n            style={{ width: \"26px\", height: \"26px\" }}\n          >\n            <path\n              fill-rule=\"evenodd\"\n              d=\"M8 0a1 1 0 0 1 1 1v5.268l4.562-2.634a1 1 0 1 1 1 1.732L10 8l4.562 2.634a1 1 0 1 1-1 1.732L9 9.732V15a1 1 0 1 1-2 0V9.732l-4.562 2.634a1 1 0 1 1-1-1.732L6 8 1.438 5.366a1 1 0 0 1 1-1.732L7 6.268V1a1 1 0 0 1 1-1z\"\n            />\n          </svg>\n          <span className=\"legend-item\">End node</span>\n        </span>\n\n        <span className=\"legend-item time\">\n          <svg\n            width=\"1em\"\n            height=\"1em\"\n            viewBox=\"0 0 16 16\"\n            class=\"bi bi-clock m-2\"\n            fill=\"currentColor\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n          >\n            <path\n              fill-rule=\"evenodd\"\n              d=\"M8 15A7 7 0 1 0 8 1a7 7 0 0 0 0 14zm8-7A8 8 0 1 1 0 8a8 8 0 0 1 16 0z\"\n            />\n            <path\n              fill-rule=\"evenodd\"\n              d=\"M7.5 3a.5.5 0 0 1 .5.5v5.21l3.248 1.856a.5.5 0 0 1-.496.868l-3.5-2A.5.5 0 0 1 7 9V3.5a.5.5 0 0 1 .5-.5z\"\n            />\n          </svg>\n          <span\n            className=\"legend-item time\"\n            key={this.props.legend.timeTaken}\n          >{`${this.props.legend.timeTaken} ms to find path`}</span>\n        </span>\n      </div>\n    );\n  }\n}\n\nexport default Legend;\n","import React, { Component } from \"react\";\nimport \"./node.css\";\n\nclass Node extends Component {\n  getClasses() {\n    let classes = \"node \";\n    const {\n      isStart,\n      isEnd,\n      isVisited,\n      isWall,\n      isPath,\n      isAnimating,\n    } = this.props.node;\n\n    classes += isStart\n      ? \"start\"\n      : isEnd\n      ? \"end\"\n      : isWall\n      ? \"wall\"\n      : // : isVisited\n        // ? \"visited\"\n        // : isPath\n        // ? \"path\"\n        \"\";\n\n    // if not currently animating nodes, keep nodes stagnant colours\n    if (!isAnimating) {\n      if (isPath) {\n        classes = \"path \" + classes;\n      } else if (isVisited) {\n        classes = \"visited \" + classes;\n      }\n    }\n\n    return classes;\n  }\n\n  render() {\n    const { col, row, isStart, isEnd } = this.props.node;\n\n    // if node is start/end, render specific symbol on top of the node\n    let startEndNode;\n\n    if (isStart) {\n      startEndNode = (\n        <div\n          className=\"startWrap\"\n          onMouseDown={() => this.props.onMouseDown(col, row)}\n          onMouseEnter={() => this.props.onMouseEnter(col, row)}\n          onMouseUp={() => this.props.onMouseUp()}\n        ></div>\n      );\n    } else if (isEnd) {\n      startEndNode = (\n        // <div\n        //   className=\"endWrap\"\n        //   onMouseDown={() => this.props.onMouseDown(col, row)}\n        //   onMouseEnter={() => this.props.onMouseEnter(col, row)}\n        //   onMouseUp={() => this.props.onMouseUp()}\n        // ></div>\n        <svg\n          width=\"1em\"\n          height=\"1em\"\n          viewBox=\"0 0 16 16\"\n          class=\"bi bi-asterisk mx-auto my-1 \"\n          style={{\n            width: \"24px\",\n            height: \"23px\",\n            display: \"block\",\n            cursor: \"pointer\",\n            position: \"absolute\",\n          }}\n          fill=\"currentColor\"\n          xmlns=\"http://www.w3.org/2000/svg\"\n          onMouseDown={() => this.props.onMouseDown(col, row)}\n          onMouseEnter={() => this.props.onMouseEnter(col, row)}\n          onMouseUp={() => this.props.onMouseUp()}\n        >\n          <path\n            fill-rule=\"evenodd\"\n            d=\"M8 0a1 1 0 0 1 1 1v5.268l4.562-2.634a1 1 0 1 1 1 1.732L10 8l4.562 2.634a1 1 0 1 1-1 1.732L9 9.732V15a1 1 0 1 1-2 0V9.732l-4.562 2.634a1 1 0 1 1-1-1.732L6 8 1.438 5.366a1 1 0 0 1 1-1.732L7 6.268V1a1 1 0 0 1 1-1z\"\n          />\n        </svg>\n      );\n    }\n\n    return (\n      <div className=\"wrap\">\n        {startEndNode}\n        <div\n          onMouseDown={() => this.props.onMouseDown(col, row)}\n          onMouseEnter={() => this.props.onMouseEnter(col, row)}\n          onMouseUp={() => this.props.onMouseUp()}\n          className={this.getClasses()}\n          id={`node ${col} ${row}`}\n        ></div>\n      </div>\n    );\n  }\n}\n\nexport default Node;\n","export default class PriorityQueue {\n  constructor(scoreFunction) {\n    this.heap = [null];\n    this.scoreFunction = scoreFunction;\n  }\n\n  push(value) {\n    this.heap.push(value);\n    this.heapifyUp(this.heap.length - 1);\n  }\n\n  pop() {\n    const min = this.heap[1];\n    this.heap[1] = this.heap[this.heap.length - 1];\n    this.heap.pop();\n    this.heapifyDown(1);\n    return min;\n  }\n\n  isEmpty() {\n    return this.heap.length === 1;\n  }\n\n  peek() {\n    const min = this.heap[1];\n    return min;\n  }\n\n  leftChild(idx) {\n    return 2 * idx;\n  }\n\n  rightChild(idx) {\n    return 2 * idx + 1;\n  }\n\n  parent(idx) {\n    return Math.floor(idx / 2);\n  }\n\n  hasAChild(idx) {\n    return this.leftChild(idx) < this.heap.length;\n  }\n\n  /**\n   * returns the child of the current index with the lowest score\n   * assume function will be called only if currIdx has a child\n   * @param {*} currIdx\n   */\n  minChild(currIdx) {\n    const leftIdx = this.leftChild(currIdx);\n    const rightIdx = this.rightChild(currIdx);\n\n    // if no right child, then return left child\n    if (rightIdx >= this.heap.length) {\n      return leftIdx;\n    }\n\n    const leftScore = this.scoreFunction(this.heap[leftIdx]);\n    const rightScore = this.scoreFunction(this.heap[rightIdx]);\n\n    if (leftScore < rightScore) {\n      return leftIdx;\n    }\n\n    return rightIdx;\n  }\n\n  heapifyDown(currIdx) {\n    if (this.hasAChild(currIdx)) {\n      const minChildIdx = this.minChild(currIdx);\n\n      const childScore = this.scoreFunction(this.heap[minChildIdx]);\n      const currScore = this.scoreFunction(this.heap[currIdx]);\n\n      if (currScore > childScore) {\n        this.swap(currIdx, minChildIdx);\n        this.heapifyDown(minChildIdx);\n      }\n    }\n  }\n\n  heapifyUp(currIdx) {\n    if (currIdx === 1) {\n      return;\n    }\n\n    const parentIdx = this.parent(currIdx);\n\n    const currScore = this.scoreFunction(this.heap[currIdx]);\n    const parentScore = this.scoreFunction(this.heap[parentIdx]);\n\n    if (currScore < parentScore) {\n      this.swap(currIdx, parentIdx);\n      this.heapifyUp(parentIdx);\n    }\n  }\n\n  swap(idxA, idxB) {\n    let temp = this.heap[idxA];\n    this.heap[idxA] = this.heap[idxB];\n    this.heap[idxB] = temp;\n  }\n}\n","import PriorityQueue from \"./PriorityQueue\";\n\nexport function dijkstras(graph, startNode, endNode) {\n  // track visited nodes in order\n  let visited = [];\n\n  let pq = new PriorityQueue(function (node) {\n    return node.distance;\n  });\n\n  // initialize source\n  startNode.distance = 0;\n  pq.push(startNode);\n  // start at source node\n\n  while (!pq.isEmpty()) {\n    let currNode = pq.pop();\n    // console.log(currNode);\n\n    const { col, row } = currNode;\n\n    currNode.isVisited = true;\n    visited.push(currNode);\n    // if current node is end node, we are done searching\n    if (currNode === endNode) {\n      return visited;\n    }\n\n    // for each unvisited neighbour:\n    let neighbours = getUnvisitedNeighbours(graph, currNode);\n    for (let neighbour of neighbours) {\n      // update distance from start node and predecessor\n      if (currNode.distance + 1 < neighbour.distance) {\n        neighbour.distance = currNode.distance + 1;\n        neighbour.predecessor = currNode;\n        pq.push(neighbour);\n      }\n    }\n  }\n\n  return visited;\n}\n\n/*\nreturns shortest path from startNode to endNode\n*/\nexport function getShortestPath(endNode) {\n  const path = [];\n\n  // If there is no path to the endNode i.e the endNode does not have a predecessor\n  if (endNode.predecessor === null) {\n    return [];\n  }\n\n  let currNode = endNode;\n  while (currNode !== null) {\n    currNode.isPath = true;\n    path.push(currNode);\n    currNode = currNode.predecessor;\n  }\n\n  return path.reverse();\n}\n\n/*\nreturns unvisited, non-wall neighbours (N, E, S, W) of given node \n*/\nexport function getUnvisitedNeighbours(graph, node) {\n  const neighbours = [];\n  const { col, row } = node;\n  if (row > 0) neighbours.push(graph[col][row - 1]);\n  if (col < graph.length - 1) neighbours.push(graph[col + 1][row]);\n  if (row < graph[0].length - 1) neighbours.push(graph[col][row + 1]);\n  if (col > 0) neighbours.push(graph[col - 1][row]);\n\n  return neighbours.filter((n) => !n.isVisited && !n.isWall);\n}\n","export default class Queue {\n  constructor() {\n    this.elems = [];\n    this.first = 0; // index of first element in array\n    this.size = 0; // number of items in array\n  }\n\n  /**\n   * pushes given object to end of queue\n   * @param {*} elem\n   */\n  enqueue(elem) {\n    this.elems.push(elem);\n    this.size++;\n  }\n\n  /**\n   * returns and removes object at front of queue\n   * resizes array downward when elements can fit into the first\n   * 0...k-1 indices of the array to achieve O(1) amortized runtime\n   *\n   * assume function will not be called on an empty queue\n   */\n  dequeue() {\n    const front = this.elems[this.first];\n    this.elems[this.first] = null;\n    this.first++;\n    this.size--;\n\n    if (!this.isEmpty() && this.size === this.first) {\n      // const newArray = this.elems.slice(this.first);\n      // let newArray = [];\n      // for (let i = 0; i < this.size; i++) {\n      //   newArray.push(this.elems[i + this.first]);\n      // }\n\n      this.elems.splice(0, this.first);\n\n      // this.elems = newArray;\n      this.first = 0;\n    }\n\n    return front;\n  }\n\n  /**\n   * returns whether queue is empty\n   */\n  isEmpty() {\n    return this.size === 0;\n  }\n\n  /**\n   * returns object at front of queue without removing it\n   */\n  front() {\n    return this.elems[this.first];\n  }\n\n  peek() {\n    console.log(this.elems.slice());\n    console.log(this.first);\n    console.log(this.size);\n  }\n}\n","import Queue from \"./Queue\";\nimport { getUnvisitedNeighbours } from \"./dijkstras\";\n\nexport function bfs(graph, startNode, endNode) {\n  const q = new Queue();\n  const visited = [];\n\n  q.enqueue(startNode);\n  visited.push(startNode);\n  startNode.isVisited = true;\n\n  while (!q.isEmpty()) {\n    let currNode = q.dequeue();\n\n    let neighbours = getUnvisitedNeighbours(graph, currNode);\n    for (let neighbour of neighbours) {\n      neighbour.isVisited = true;\n      visited.push(neighbour);\n      neighbour.predecessor = currNode;\n\n      if (neighbour === endNode) {\n        return visited;\n      }\n\n      q.enqueue(neighbour);\n    }\n  }\n\n  return visited;\n}\n","export default class Stack {\n  constructor() {\n    this.elems = [];\n  }\n\n  push(elem) {\n    this.elems.push(elem);\n  }\n\n  pop() {\n    return this.elems.pop();\n  }\n\n  isEmpty() {\n    return this.elems.length === 0;\n  }\n\n  peek() {\n    return this.elems[this.elems.length - 1];\n  }\n}\n","import Stack from \"./Stack\";\nimport { getUnvisitedNeighbours } from \"./dijkstras\";\n\nexport function dfs(graph, startNode, endNode) {\n  const stack = new Stack();\n  const visited = [];\n\n  stack.push(startNode);\n  visited.push(startNode);\n  startNode.isVisited = true;\n\n  while (!stack.isEmpty()) {\n    let currNode = stack.pop();\n\n    let neighbours = getUnvisitedNeighbours(graph, currNode);\n    for (let neighbour of neighbours) {\n      neighbour.isVisited = true;\n      visited.push(neighbour);\n      neighbour.predecessor = currNode;\n\n      if (neighbour === endNode) {\n        return visited;\n      }\n\n      stack.push(neighbour);\n    }\n  }\n\n  return visited;\n}\n","import PriorityQueue from \"./PriorityQueue\";\nimport { getUnvisitedNeighbours } from \"./dijkstras\";\n\nexport function aStar(graph, startNode, endNode) {\n  const openSet = new PriorityQueue(function (node) {\n    return node.f;\n  });\n\n  const visited = []; // closed set\n\n  // initialize open set\n  startNode.f = 0;\n  startNode.distance = 0;\n  openSet.push(startNode);\n\n  while (!openSet.isEmpty()) {\n    // find node with least f on open set\n    let currNode = openSet.pop();\n\n    currNode.isVisited = true;\n    visited.push(currNode);\n\n    if (currNode === endNode) {\n      return visited;\n    }\n\n    let neighbours = getUnvisitedNeighbours(graph, currNode);\n    for (let neighbour of neighbours) {\n      if (currNode.distance + 1 < neighbour.distance) {\n        neighbour.predecessor = currNode;\n        neighbour.distance = currNode.distance + 1;\n\n        // calculate manhattan distance heuristic for neighbour\n        let h =\n          Math.abs(neighbour.col - endNode.col) +\n          Math.abs(neighbour.row - endNode.row);\n        let g = neighbour.distance;\n        neighbour.f = g + h;\n\n        openSet.push(neighbour);\n      }\n    }\n  }\n\n  return visited;\n}\n","import React, { Component } from \"react\";\nimport NavBar from \"./components/navbar\";\nimport {\n  DIJKSTRAS_LABEL,\n  BFS_LABEL,\n  DFS_LABEL,\n  ASTAR_LABEL,\n} from \"./components/navbar\";\nimport Legend from \"./components/legend\";\nimport Node from \"./components/node.jsx\";\nimport \"./PathfindingVisualizer.css\";\nimport { dijkstras, getShortestPath } from \"./algorithms/dijkstras\";\nimport { bfs } from \"./algorithms/bfs\";\nimport { dfs } from \"./algorithms/dfs\";\nimport { aStar } from \"./algorithms/aStar\";\n\nconst START_NODE_X = 12;\nconst START_NODE_Y = 10;\nconst END_NODE_X = 30;\nconst END_NODE_Y = 10;\nconst NUM_COLS = 43;\nconst NUM_ROWS = 21;\nconst TIME = 0;\n\nclass PathfindingVisualizer extends Component {\n  state = {\n    nodes: [],\n    start: { x: START_NODE_X, y: START_NODE_Y },\n    end: { x: END_NODE_X, y: END_NODE_Y },\n    mouseIsPressed: false,\n    startIsPressed: false,\n    endIsPressed: false,\n    selectedAlgorithm: \"\",\n    legend: {\n      timeTaken: TIME.toFixed(3),\n      algorithmMessage: \"\",\n    },\n    isAnimating: false,\n  };\n\n  componentDidMount() {\n    const nodes = this.getInitialGraph();\n    this.setState({ nodes });\n  }\n\n  /**\n   * animates the given visited nodes in order\n   * and the shortest path in order after the visited nodes\n   */\n  // visualize = (visitedNodes, shortestPath) => {\n  //   this.resetNodesToUnvisited();\n  //   const startTime = performance.now();\n\n  //   // for each visited node:\n  //   // one extra iteration to animate path\n  //   for (let i = 0; i <= visitedNodes.length; i++) {\n  //     // if on last iteration, animate path\n  //     // timeout proportional to iteration number so path animates after visited nodes\n  //     if (i === visitedNodes.length) {\n  //       setTimeout(() => {\n  //         // get time allotted for searching animation to finish\n  //         console.log(this.getTimeAlotted(startTime));\n  //         const time = this.getTimeAlotted(startTime);\n  //         // this.setState({ legend: { timeTaken: time } });\n\n  //         this.animatePath(shortestPath);\n  //       }, 15 * i);\n\n  //       return;\n  //     }\n\n  //     let currNode = visitedNodes[i];\n  //     const { col, row } = currNode;\n  //     // animate each node to change colour one after another\n  //     // timeout based on position in list so that\n  //     // each node should only changes colour after the previously visited one has changed colour\n  //     setTimeout(() => {\n  //       document.getElementById(`node ${col} ${row}`).className += \" visited\";\n  //     }, 15 * i);\n  //   }\n  // };\n\n  /**\n   * animates traversal of given algorithm on current graph state\n   * @param {*} algorithm algorithm to visualize\n   */\n  visualize(algorithm) {\n    this.resetNodesToUnvisited();\n\n    // deep copy of the state's nodes\n    const graph = this.state.nodes.map((col) => {\n      return col.map((node) => {\n        let newNode = {};\n        for (let key in node) {\n          newNode[key] = node[key];\n        }\n        return newNode;\n      });\n    });\n\n    const { start, end } = this.state;\n    const startNode = graph[start.x][start.y];\n    const endNode = graph[end.x][end.y];\n    const startTime = performance.now();\n\n    const visitedNodes = algorithm(graph, startNode, endNode);\n\n    // get time allotted for searching animation to finish\n    const endTime = performance.now();\n    const time = (endTime - startTime).toFixed(3);\n\n    // start animation of traversal\n    this.setState({ isAnimating: true });\n    // for each visited node:\n    // one extra iteration to animate path\n    for (let i = 0; i <= visitedNodes.length; i++) {\n      // if on last iteration, animate path\n      // timeout proportional to iteration number so path animates after visited nodes\n      if (i === visitedNodes.length) {\n        setTimeout(() => {\n          const shortestPath = getShortestPath(endNode);\n          this.animatePath(shortestPath);\n\n          setTimeout(() => {\n            this.setState({ nodes: graph, isAnimating: false });\n\n            this.setState({ legend: { timeTaken: time } });\n          }, 30 * shortestPath.length + 1200); /** delay until last iteration of path animation\n                                                plus amount of seconds to animate path node */\n        }, 15 * i + 500);\n\n        return;\n      }\n\n      let currNode = visitedNodes[i];\n      const { col, row } = currNode;\n      // animate each node to change colour one after another\n      // timeout based on position in list so that\n      // each node should only changes colour after the previously visited one has changed colour\n      setTimeout(() => {\n        document.getElementById(`node ${col} ${row}`).className +=\n          \" visited-animation\";\n      }, 15 * i);\n    }\n  }\n\n  /**\n   * animates the given shortest path nodes in order\n   * @param {*} shortestPath\n   */\n  animatePath(shortestPath) {\n    for (let i = 0; i < shortestPath.length; i++) {\n      let currNode = shortestPath[i];\n      const { col, row } = currNode;\n      setTimeout(() => {\n        document.getElementById(`node ${col} ${row}`).className +=\n          \" path-animation\";\n      }, 30 * i);\n    }\n  }\n\n  // /**\n  //  * returns time allotted since start time in s\n  //  * @param {*} startTime\n  //  */\n  // getTimeAlotted(startTime) {\n  //   const endTime = performance.now();\n  //   const time = endTime - startTime;\n  //   return time.toFixed(3);\n  // }\n\n  handleMouseDown = (x, y) => {\n    const graph = [...this.state.nodes];\n    const currNode = graph[x][y];\n    if (!currNode.isStart && !currNode.isEnd) {\n      this.toggleWall(currNode, graph);\n      this.setState({ mouseIsPressed: true });\n    } else {\n      if (currNode.isStart) {\n        this.setState({ mouseIsPressed: true, startIsPressed: true });\n      } else {\n        this.setState({ mouseIsPressed: true, endIsPressed: true });\n      }\n    }\n  };\n\n  handleMouseEnter = (x, y) => {\n    if (!this.state.mouseIsPressed) {\n      return;\n    }\n\n    const graph = [...this.state.nodes];\n    const currNode = graph[x][y];\n\n    if (this.state.startIsPressed) {\n      this.changeStartNode(currNode, graph);\n      return;\n    } else if (this.state.endIsPressed) {\n      this.changeEndNode(currNode, graph);\n      return;\n    }\n\n    if (!currNode.isStart && !currNode.isEnd) {\n      this.toggleWall(currNode, graph);\n    }\n  };\n\n  handleMouseUp = () => {\n    // make sure that where start and end node are placed is not ON a wall\n    const nodes = [...this.state.nodes];\n    const { start, end } = this.state;\n    nodes[start.x][start.y].isWall = false;\n    nodes[end.x][end.y].isWall = false;\n\n    this.setState({\n      nodes,\n      mouseIsPressed: false,\n      startIsPressed: false,\n      endIsPressed: false,\n    });\n  };\n\n  setSelectedAlgorithm = (algorithm) => {\n    this.setState({ selectedAlgorithm: algorithm });\n  };\n\n  // handleVisualize = () => {\n  //   const { selectedAlgorithm } = this.state;\n  //   const graph = [...this.state.nodes];\n  //   const { start, end } = this.state;\n  //   const startNode = graph[start.x][start.y];\n  //   const endNode = graph[end.x][end.y];\n\n  //   let visitedNodes = null;\n\n  //   switch (selectedAlgorithm) {\n  //     case \"Dijkstra's\":\n  //       visitedNodes = dijkstras(graph, startNode, endNode);\n  //       break;\n  //     case \"BFS\":\n  //       visitedNodes = bfs(graph, startNode, endNode);\n  //       break;\n  //     case \"DFS\":\n  //       visitedNodes = dfs(graph, startNode, endNode);\n  //       break;\n  //     case \"A*\":\n  //       visitedNodes = aStar(graph, startNode, endNode);\n  //       break;\n  //     default:\n  //       this.setState({ popoverOpen: true });\n  //       return;\n  //   }\n  //   const shortestPath = getShortestPath(endNode);\n  //   this.visualize(visitedNodes, shortestPath);\n  // };\n\n  handleVisualize = () => {\n    const { selectedAlgorithm } = this.state;\n\n    switch (selectedAlgorithm) {\n      case DIJKSTRAS_LABEL:\n        this.visualize(dijkstras);\n        break;\n      case BFS_LABEL:\n        this.visualize(bfs);\n        break;\n      case DFS_LABEL:\n        this.visualize(dfs);\n        break;\n      case ASTAR_LABEL:\n        this.visualize(aStar);\n        break;\n      default:\n        alert(\"Select an algorithm to visualize!\");\n        return;\n    }\n  };\n\n  /**\n   * resets graph to the intial graph\n   */\n  handleReset = () => {\n    const nodes = this.getInitialGraph();\n    this.setState({\n      nodes,\n      start: { x: START_NODE_X, y: START_NODE_Y },\n      end: { x: END_NODE_X, y: END_NODE_Y },\n    });\n  };\n\n  /**\n   * clears all walls from graph without moving start and end nodes\n   */\n  clearWalls = () => {\n    const graph = [...this.state.nodes];\n    for (let x = 0; x < NUM_COLS; x++) {\n      for (let y = 0; y < NUM_ROWS; y++) {\n        let node = graph[x][y];\n        node.isWall = false;\n      }\n    }\n\n    this.setState({ nodes: graph });\n  };\n\n  render() {\n    return (\n      <React.Fragment>\n        <NavBar\n          setAlgorithm={this.setSelectedAlgorithm}\n          selectedAlgorithm={this.state.selectedAlgorithm}\n          onVisualize={this.handleVisualize}\n          onReset={this.handleReset}\n          onClearPath={this.resetNodesToUnvisited}\n          onClearWalls={this.clearWalls}\n        />\n        <Legend legend={this.state.legend} />\n        <div key={new Date()} className=\"grid\">\n          {this.state.nodes.map((col, colIdx) => {\n            return (\n              <div key={colIdx}>\n                {col.map((node, rowIdx) => (\n                  <Node\n                    key={rowIdx}\n                    onMouseDown={this.handleMouseDown}\n                    onMouseEnter={this.handleMouseEnter}\n                    onMouseUp={this.handleMouseUp}\n                    isAnimating={this.state.isAnimating}\n                    node={node}\n                  />\n                ))}\n              </div>\n            );\n          })}\n        </div>\n      </React.Fragment>\n    );\n  }\n\n  /**\n   * \ttoggles the given node at x,y on the graph as/not as a wall\n   * @param {*} currNode\n   * @param {*} graph\n   */\n  toggleWall(currNode, graph) {\n    const newNode = {\n      ...currNode,\n      isWall: !currNode.isWall,\n    };\n\n    graph[currNode.col][currNode.row] = newNode;\n    this.setState({ nodes: graph });\n  }\n\n  /**\n   * sets given node as the end node\n   * @param {*} currNode\n   * @param {*} graph\n   */\n  changeEndNode(currNode, graph) {\n    const { col, row } = currNode;\n    const { x, y } = this.state.end;\n    graph[x][y].isEnd = false;\n    currNode.isEnd = true;\n    // currNode.isWall = false;\n    this.setState({ nodes: graph, end: { x: col, y: row } });\n  }\n\n  /**\n   * sets given node as the start node\n   * @param {*} currNode\n   * @param {*} graph\n   */\n  changeStartNode(currNode, graph) {\n    const { col, row } = currNode;\n    const { x, y } = this.state.start;\n    graph[x][y].isStart = false;\n    currNode.isStart = true;\n    // currNode.isWall = false;\n    this.setState({ nodes: graph, start: { x: col, y: row } });\n  }\n\n  /**\n   * resets state's nodes to before dijkstra's was called\n   */\n  resetNodesToUnvisited = () => {\n    const graph = [...this.state.nodes];\n    for (let x = 0; x < NUM_COLS; x++) {\n      for (let y = 0; y < NUM_ROWS; y++) {\n        let node = graph[x][y];\n        node.isVisited = false;\n        node.isPath = false;\n        node.distance = Infinity;\n        node.predecessor = null;\n      }\n    }\n\n    this.setState({ nodes: graph });\n  };\n\n  /**\n   * returns initial graph with no walls toggled or visited nodes\n   */\n  getInitialGraph() {\n    const nodes = [];\n\n    for (let col = 0; col < NUM_COLS; col++) {\n      const currCol = [];\n      for (let row = 0; row < NUM_ROWS; row++) {\n        const currNode = {\n          col,\n          row,\n          isStart: col === START_NODE_X && row === START_NODE_Y,\n          isEnd: col === END_NODE_X && row === END_NODE_Y,\n          isVisited: false,\n          isWall: false,\n          isPath: false,\n          distance: Infinity,\n          f: Infinity,\n          predecessor: null,\n        };\n        currCol.push(currNode);\n      }\n      nodes.push(currCol);\n    }\n    return nodes;\n  }\n}\n\nexport default PathfindingVisualizer;\n","import \"bootstrap/dist/css/bootstrap.min.css\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport PathfindingVisualizer from \"./PathfindingVisualizer\";\n\nReactDOM.render(<PathfindingVisualizer />, document.getElementById(\"root\"));\n"],"sourceRoot":""}