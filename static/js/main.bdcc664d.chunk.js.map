{"version":3,"sources":["components/navbar.jsx","components/legend.jsx","components/node.jsx","algorithms/PriorityQueue.js","algorithms/dijkstras.js","algorithms/Queue.js","algorithms/bfs.js","algorithms/Stack.js","algorithms/dfs.js","algorithms/aStar.js","algorithms/greedyBestFirstSearch.js","PathfindingVisualizer.js","index.js"],"names":["NavBar","Navbar","collapseOnSelect","expand","bg","variant","Brand","href","Toggle","aria-controls","Collapse","id","Nav","className","NavDropdown","title","Item","onSelect","props","setAlgorithm","Button","disabled","this","isAnimating","onClick","onVisualize","selectedAlgorithm","onClearPath","onClearWalls","onReset","Component","Legend","width","height","viewBox","class","fill","xmlns","style","fill-rule","d","key","legend","timeTaken","Node","classes","isStart","isEnd","isVisited","isWall","isPath","startEndNode","col","row","onMouseDown","onMouseEnter","onMouseUp","display","cursor","position","marginLeft","marginTop","getClasses","PureComponent","PriorityQueue","scoreFunction","heap","value","push","heapifyUp","length","min","pop","heapifyDown","idx","Math","floor","leftChild","currIdx","leftIdx","rightIdx","rightChild","hasAChild","minChildIdx","minChild","childScore","swap","parentIdx","parent","idxA","idxB","temp","dijkstras","graph","startNode","endNode","visited","pq","node","distance","isEmpty","currNode","neighbours","getUnvisitedNeighbours","neighbour","predecessor","filter","n","Queue","elems","first","size","elem","front","splice","bfs","q","enqueue","dequeue","Stack","dfs","stack","aStar","openSet","f","h","abs","g","greedyBestFirstSearch","PathfindingVisualizer","state","nodes","start","x","y","end","mouseIsPressed","startIsPressed","endIsPressed","toFixed","algorithmMessage","handleMouseDown","setState","toggleWall","handleMouseEnter","changeStartNode","changeEndNode","handleMouseUp","setSelectedAlgorithm","algorithm","handleVisualize","visualize","alert","handleReset","getInitialGraph","clearWalls","resetNodesToUnvisited","Infinity","map","newNode","startTime","performance","now","visitedNodes","time","i","setTimeout","shortestPath","path","reverse","getShortestPath","animatePath","document","getElementById","Fragment","colIdx","rowIdx","currCol","ReactDOM","render"],"mappings":"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","file":"static/js/main.bdcc664d.chunk.js","sourcesContent":["import React, { Component } from \"react\";\nimport { Navbar, Nav, NavDropdown, Button } from \"react-bootstrap\";\n\nexport const DIJKSTRAS_LABEL = \"Dijkstra's\";\nexport const BFS_LABEL = \"BFS\";\nexport const DFS_LABEL = \"DFS\";\nexport const ASTAR_LABEL = \"A*\";\nexport const GREEDY_BEST_FIRST_LABEL = \"Greedy Best First Search\";\n\nclass NavBar extends Component {\n  render() {\n    return (\n      <Navbar collapseOnSelect expand=\"lg\" bg=\"light\" variant=\"light\">\n        <Navbar.Brand href=\"#home\">Pathfinding Visualizer</Navbar.Brand>\n        <Navbar.Toggle aria-controls=\"responsive-navbar-nav\" />\n        <Navbar.Collapse id=\"responsive-navbar-nav\">\n          <Nav className=\"mr-auto\">\n            <NavDropdown title=\"Algorithms\" id=\"collasible-nav-dropdown\">\n              <NavDropdown.Item\n                href=\"#action/3.1\"\n                onSelect={() => this.props.setAlgorithm(DIJKSTRAS_LABEL)}\n              >\n                Dijkstra's\n              </NavDropdown.Item>\n              <NavDropdown.Item\n                href=\"#action/3.2\"\n                onSelect={() => this.props.setAlgorithm(BFS_LABEL)}\n              >\n                Breadth First Search\n              </NavDropdown.Item>\n              <NavDropdown.Item\n                href=\"#action/3.3\"\n                onSelect={() => this.props.setAlgorithm(DFS_LABEL)}\n              >\n                Depth First Search\n              </NavDropdown.Item>\n              <NavDropdown.Item\n                href=\"#action/3.4\"\n                onSelect={() => this.props.setAlgorithm(GREEDY_BEST_FIRST_LABEL)}\n              >\n                Greedy Best First Search\n              </NavDropdown.Item>\n              <NavDropdown.Item\n                href=\"#action/3.5\"\n                onSelect={() => this.props.setAlgorithm(ASTAR_LABEL)}\n              >\n                A*\n              </NavDropdown.Item>\n            </NavDropdown>\n            <span>\n              <Button variant=\"info\" disabled={this.props.isAnimating} onClick={this.props.onVisualize}>\n                {`Visualize ${this.props.selectedAlgorithm}`}\n              </Button>{\" \"}\n            </span>\n            <Button variant=\"light\" disabled={this.props.isAnimating} onClick={this.props.onClearPath}>\n              Clear Path\n            </Button>{\" \"}\n            <Button variant=\"light\" disabled={this.props.isAnimating} onClick={this.props.onClearWalls}>\n              Clear Walls\n            </Button>{\" \"}\n            <Button variant=\"light\" disabled={this.props.isAnimating} onClick={this.props.onReset}>\n              Reset\n            </Button>\n          </Nav>\n        </Navbar.Collapse>\n      </Navbar>\n    );\n  }\n}\n\nexport default NavBar;\n","import React, { Component } from \"react\";\nimport \"./legend.css\";\n\nclass Legend extends Component {\n  render() {\n    return (\n      <div className=\"legend\">\n        <span className=\"legend-item block black\"></span>\n        <span className=\"legend-item\">Wall</span>\n        <span className=\"legend-item block green\"></span>\n        <span className=\"legend-item\">Visited node</span>\n        <span className=\"legend-item block yellow\"></span>\n        <span className=\"legend-item\">Path</span>\n        <span>\n          <span id=\"startSymbol\" className=\"legend-item\"></span>\n          <span className=\"legend-item\">Start node</span>\n        </span>\n        <span>\n          <svg\n            width=\"2em\"\n            height=\"2em\"\n            viewBox=\"0 0 16 16\"\n            class=\"bi bi-asterisk ml-2\"\n            fill=\"currentColor\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n            style={{ width: \"26px\", height: \"26px\" }}\n          >\n            <path\n              fill-rule=\"evenodd\"\n              d=\"M8 0a1 1 0 0 1 1 1v5.268l4.562-2.634a1 1 0 1 1 1 1.732L10 8l4.562 2.634a1 1 0 1 1-1 1.732L9 9.732V15a1 1 0 1 1-2 0V9.732l-4.562 2.634a1 1 0 1 1-1-1.732L6 8 1.438 5.366a1 1 0 0 1 1-1.732L7 6.268V1a1 1 0 0 1 1-1z\"\n            />\n          </svg>\n          <span className=\"legend-item\">End node</span>\n        </span>\n\n        <span className=\"legend-item time\">\n          <svg\n            width=\"1em\"\n            height=\"1em\"\n            viewBox=\"0 0 16 16\"\n            class=\"bi bi-clock m-2\"\n            fill=\"currentColor\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n          >\n            <path\n              fill-rule=\"evenodd\"\n              d=\"M8 15A7 7 0 1 0 8 1a7 7 0 0 0 0 14zm8-7A8 8 0 1 1 0 8a8 8 0 0 1 16 0z\"\n            />\n            <path\n              fill-rule=\"evenodd\"\n              d=\"M7.5 3a.5.5 0 0 1 .5.5v5.21l3.248 1.856a.5.5 0 0 1-.496.868l-3.5-2A.5.5 0 0 1 7 9V3.5a.5.5 0 0 1 .5-.5z\"\n            />\n          </svg>\n          <span\n            className=\"legend-item time\"\n            key={this.props.legend.timeTaken}\n          >{`${this.props.legend.timeTaken} ms to find path`}</span>\n        </span>\n      </div>\n    );\n  }\n}\n\nexport default Legend;\n","import React, { Component } from \"react\";\nimport { PureComponent } from \"react\";\nimport \"./node.css\";\n\nclass Node extends PureComponent {\n  getClasses() {\n    let classes = \"node \";\n    const {\n      isStart,\n      isEnd,\n      isVisited,\n      isWall,\n      isPath,\n      isAnimating,\n    } = this.props;\n\n    classes += isStart\n      ? \"start\"\n      : isEnd\n      ? \"end\"\n      : isWall\n      ? \"wall\"\n      : \"\";\n\n    // if not currently animating nodes, keep nodes stagnant colours\n    if (!isAnimating) {\n      if (isPath) {\n        classes = \"path \" + classes;\n      } else if (isVisited) {\n        classes = \"visited \" + classes;\n      }\n    }\n\n    return classes;\n  }\n\n  render() {\n    // console.log(\"rendered\")\n    const { col, row, isStart, isEnd } = this.props;\n\n    // if node is start/end, render specific symbol on top of the node\n    let startEndNode;\n\n    if (isStart) {\n      startEndNode = (\n        <div\n          className=\"startWrap\"\n          onMouseDown={() => this.props.onMouseDown(col, row)}\n          onMouseEnter={() => this.props.onMouseEnter(col, row)}\n          onMouseUp={() => this.props.onMouseUp()}\n        ></div>\n      );\n    } else if (isEnd) {\n      startEndNode = (\n        // following commented code is a shape for the end node that I can't decide if I like better\n        // <div\n        //   className=\"endWrap\"\n        //   onMouseDown={() => this.props.onMouseDown(col, row)}\n        //   onMouseEnter={() => this.props.onMouseEnter(col, row)}\n        //   onMouseUp={() => this.props.onMouseUp()}\n        // ></div>\n        <svg\n          width=\"1em\"\n          height=\"1em\"\n          viewBox=\"0 0 16 16\"\n          class=\"bi bi-asterisk \"\n          style={{\n            width: \"24px\",\n            height: \"24px\",\n            display: \"block\",\n            cursor: \"pointer\",\n            position: \"absolute\",\n            marginLeft: \"2px\",\n            marginTop: \"2px\",\n          }}\n          fill=\"currentColor\"\n          xmlns=\"http://www.w3.org/2000/svg\"\n          onMouseDown={() => this.props.onMouseDown(col, row)}\n          onMouseEnter={() => this.props.onMouseEnter(col, row)}\n          onMouseUp={() => this.props.onMouseUp()}\n        >\n          <path\n            fill-rule=\"evenodd\"\n            d=\"M8 0a1 1 0 0 1 1 1v5.268l4.562-2.634a1 1 0 1 1 1 1.732L10 8l4.562 2.634a1 1 0 1 1-1 1.732L9 9.732V15a1 1 0 1 1-2 0V9.732l-4.562 2.634a1 1 0 1 1-1-1.732L6 8 1.438 5.366a1 1 0 0 1 1-1.732L7 6.268V1a1 1 0 0 1 1-1z\"\n          />\n        </svg>\n      );\n    }\n\n    return (\n      <div className=\"wrap\">\n        {startEndNode}\n        <div\n          onMouseDown={() => this.props.onMouseDown(col, row)}\n          onMouseEnter={() => this.props.onMouseEnter(col, row)}\n          onMouseUp={() => this.props.onMouseUp()}\n          className={this.getClasses()}\n          id={`node ${col} ${row}`}\n        ></div>\n      </div>\n    );\n  }\n}\n\nexport default Node;\n","export default class PriorityQueue {\n  constructor(scoreFunction) {\n    this.heap = [null];\n    this.scoreFunction = scoreFunction;\n  }\n\n  /**\n   * pushes value into priority queue\n   * @param {*} value \n   */\n  push(value) {\n    this.heap.push(value);\n    this.heapifyUp(this.heap.length - 1);\n  }\n\n  /**\n   * returns and removes minimum value in priority queue\n   */\n  pop() {\n    const min = this.heap[1];\n    this.heap[1] = this.heap[this.heap.length - 1];\n    this.heap.pop();\n    this.heapifyDown(1);\n    return min;\n  }\n\n  /**\n   * returns true if priority queue is empty\n   */\n  isEmpty() {\n    return this.heap.length === 1;\n  }\n\n  /**\n   * returns minimum value without removing it from priority queue\n   */\n  peek() {\n    const min = this.heap[1];\n    return min;\n  }\n\n  /**\n   * returns index of the left child of element at given index\n   * @param {*} idx \n   */\n  leftChild(idx) {\n    return 2 * idx;\n  }\n\n  /**\n   * returns index of right child of element at given index\n   * @param {*} idx \n   */\n  rightChild(idx) {\n    return 2 * idx + 1;\n  }\n\n  /**\n   * returns index of parent of element at given index\n   * @param {*} idx \n   */\n  parent(idx) {\n    return Math.floor(idx / 2);\n  }\n\n  /**\n   * returns true if element at given index has a child\n   * @param {*} idx \n   */\n  hasAChild(idx) {\n    return this.leftChild(idx) < this.heap.length;\n  }\n\n  /**\n   * returns the child of the current index with the lowest score\n   * assume function will be called only if currIdx has a child\n   * @param {*} currIdx\n   */\n  minChild(currIdx) {\n    const leftIdx = this.leftChild(currIdx);\n    const rightIdx = this.rightChild(currIdx);\n\n    // if no right child, then return left child\n    if (rightIdx >= this.heap.length) {\n      return leftIdx;\n    }\n\n    const leftScore = this.scoreFunction(this.heap[leftIdx]);\n    const rightScore = this.scoreFunction(this.heap[rightIdx]);\n\n    if (leftScore < rightScore) {\n      return leftIdx;\n    }\n\n    return rightIdx;\n  }\n\n  /**\n   * restores heap order by swapping down from given index until all children \n   * are larger than parents.\n   * @param {*} currIdx \n   */\n  heapifyDown(currIdx) {\n    if (this.hasAChild(currIdx)) {\n      const minChildIdx = this.minChild(currIdx);\n\n      const childScore = this.scoreFunction(this.heap[minChildIdx]);\n      const currScore = this.scoreFunction(this.heap[currIdx]);\n\n      if (currScore > childScore) {\n        this.swap(currIdx, minChildIdx);\n        this.heapifyDown(minChildIdx);\n      }\n    }\n  }\n\n  /**\n   * restores heap order by swapping up from given index until all children \n   * are larger than parents\n   * @param {*} currIdx \n   */\n  heapifyUp(currIdx) {\n    if (currIdx === 1) {\n      return;\n    }\n\n    const parentIdx = this.parent(currIdx);\n\n    const currScore = this.scoreFunction(this.heap[currIdx]);\n    const parentScore = this.scoreFunction(this.heap[parentIdx]);\n\n    if (currScore < parentScore) {\n      this.swap(currIdx, parentIdx);\n      this.heapifyUp(parentIdx);\n    }\n  }\n\n  /**\n   * swap elements at idxA and idxB in the priority queue\n   * @param {*} idxA \n   * @param {*} idxB \n   */\n  swap(idxA, idxB) {\n    let temp = this.heap[idxA];\n    this.heap[idxA] = this.heap[idxB];\n    this.heap[idxB] = temp;\n  }\n}\n","import PriorityQueue from \"./PriorityQueue\";\n\nexport function dijkstras(graph, startNode, endNode) {\n  // track visited nodes in order\n  let visited = [];\n\n  let pq = new PriorityQueue(function (node) {\n    return node.distance;\n  });\n\n  // initialize source\n  startNode.distance = 0;\n  pq.push(startNode);\n  // start at source node\n\n  while (!pq.isEmpty()) {\n    let currNode = pq.pop();\n    // console.log(currNode);\n\n    const { col, row } = currNode;\n\n    currNode.isVisited = true;\n    visited.push(currNode);\n    // if current node is end node, we are done searching\n    if (currNode === endNode) {\n      return visited;\n    }\n\n    // for each unvisited neighbour:\n    let neighbours = getUnvisitedNeighbours(graph, currNode);\n    for (let neighbour of neighbours) {\n      // update distance from start node and predecessor\n      if (currNode.distance + 1 < neighbour.distance) {\n        neighbour.distance = currNode.distance + 1;\n        neighbour.predecessor = currNode;\n        pq.push(neighbour);\n      }\n    }\n  }\n\n  return visited;\n}\n\n/*\nreturns shortest path from startNode to endNode\n*/\nexport function getShortestPath(endNode) {\n  const path = [];\n\n  // If there is no path to the endNode i.e the endNode does not have a predecessor\n  if (endNode.predecessor === null) {\n    return [];\n  }\n\n  let currNode = endNode;\n  while (currNode !== null) {\n    currNode.isPath = true;\n    path.push(currNode);\n    currNode = currNode.predecessor;\n  }\n\n  return path.reverse();\n}\n\n/*\nreturns unvisited, non-wall neighbours (N, E, S, W) of given node \n*/\nexport function getUnvisitedNeighbours(graph, node) {\n  const neighbours = [];\n  const { col, row } = node;\n  if (row > 0) neighbours.push(graph[col][row - 1]);\n  if (col < graph.length - 1) neighbours.push(graph[col + 1][row]);\n  if (row < graph[0].length - 1) neighbours.push(graph[col][row + 1]);\n  if (col > 0) neighbours.push(graph[col - 1][row]);\n\n  return neighbours.filter((n) => !n.isVisited && !n.isWall);\n}\n","export default class Queue {\n  constructor() {\n    this.elems = [];\n    this.first = 0; // index of first element in array\n    this.size = 0; // number of items in array\n  }\n\n  /**\n   * pushes given object to end of queue\n   * @param {*} elem\n   */\n  enqueue(elem) {\n    this.elems.push(elem);\n    this.size++;\n  }\n\n  /**\n   * returns and removes object at front of queue\n   * resizes array downward when elements can fit into the first\n   * 0...k-1 indices of the array to achieve O(1) amortized runtime\n   *\n   * assume function will not be called on an empty queue\n   */\n  dequeue() {\n    const front = this.elems[this.first];\n    this.elems[this.first] = null;\n    this.first++;\n    this.size--;\n\n    if (!this.isEmpty() && this.size === this.first) {\n      this.elems.splice(0, this.first);\n      this.first = 0;\n    }\n\n    return front;\n  }\n\n  /**\n   * returns whether queue is empty\n   */\n  isEmpty() {\n    return this.size === 0;\n  }\n\n  /**\n   * returns object at front of queue without removing it\n   */\n  front() {\n    return this.elems[this.first];\n  }\n\n}\n","import Queue from \"./Queue\";\nimport { getUnvisitedNeighbours } from \"./dijkstras\";\n\nexport function bfs(graph, startNode, endNode) {\n  const q = new Queue();\n  const visited = [];\n\n  q.enqueue(startNode);\n  visited.push(startNode);\n  startNode.isVisited = true;\n\n  while (!q.isEmpty()) {\n    let currNode = q.dequeue();\n\n    let neighbours = getUnvisitedNeighbours(graph, currNode);\n    for (let neighbour of neighbours) {\n      neighbour.isVisited = true;\n      visited.push(neighbour);\n      neighbour.predecessor = currNode;\n\n      if (neighbour === endNode) {\n        return visited;\n      }\n\n      q.enqueue(neighbour);\n    }\n  }\n\n  return visited;\n}\n","export default class Stack {\n  constructor() {\n    this.elems = [];\n  }\n\n  /**\n   * pushes elem to top of stack\n   * @param {*} elem \n   */\n  push(elem) {\n    this.elems.push(elem);\n  }\n\n  /**\n   * returns and removes elem on top of stack\n   */\n  pop() {\n    return this.elems.pop();\n  }\n\n  /**\n   * returns true if stack is empty\n   */\n  isEmpty() {\n    return this.elems.length === 0;\n  }\n\n  /**\n   * returns elem on top of stack without removing it\n   */\n  peek() {\n    return this.elems[this.elems.length - 1];\n  }\n}\n","import Stack from \"./Stack\";\nimport { getUnvisitedNeighbours } from \"./dijkstras\";\n\nexport function dfs(graph, startNode, endNode) {\n  const stack = new Stack();\n  const visited = [];\n\n  stack.push(startNode);\n  visited.push(startNode);\n  startNode.isVisited = true;\n\n  while (!stack.isEmpty()) {\n    let currNode = stack.pop();\n\n    let neighbours = getUnvisitedNeighbours(graph, currNode);\n    for (let neighbour of neighbours) {\n      neighbour.isVisited = true;\n      visited.push(neighbour);\n      neighbour.predecessor = currNode;\n\n      if (neighbour === endNode) {\n        return visited;\n      }\n\n      stack.push(neighbour);\n    }\n  }\n\n  return visited;\n}\n","import PriorityQueue from \"./PriorityQueue\";\nimport { getUnvisitedNeighbours } from \"./dijkstras\";\n\nexport function aStar(graph, startNode, endNode) {\n  const openSet = new PriorityQueue(function (node) {\n    return node.f;\n  });\n\n  const visited = []; // closed set\n\n  // initialize open set\n  startNode.f = 0;\n  startNode.distance = 0;\n  openSet.push(startNode);\n\n  while (!openSet.isEmpty()) {\n    // find node with least f on open set\n    let currNode = openSet.pop();\n\n    currNode.isVisited = true;\n    visited.push(currNode);\n\n    if (currNode === endNode) {\n      return visited;\n    }\n\n    let neighbours = getUnvisitedNeighbours(graph, currNode);\n    for (let neighbour of neighbours) {\n      if (currNode.distance + 1 < neighbour.distance) {\n        neighbour.predecessor = currNode;\n        neighbour.distance = currNode.distance + 1;\n\n        // calculate manhattan distance heuristic for neighbour\n        let h =\n          Math.abs(neighbour.col - endNode.col) +\n          Math.abs(neighbour.row - endNode.row);\n        let g = neighbour.distance;\n        neighbour.f = g + h;\n\n        openSet.push(neighbour);\n      }\n    }\n  }\n\n  return visited;\n}\n","import PriorityQueue from \"./PriorityQueue\";\nimport { getUnvisitedNeighbours } from \"./dijkstras\";\n\nexport function greedyBestFirstSearch(graph, startNode, endNode) {\n    const openSet = new PriorityQueue(function (node) {\n        return node.f;\n      });\n    \n      const visited = []; // closed set\n    \n      // initialize open set\n      startNode.f = 0;\n      startNode.distance = 0;\n      openSet.push(startNode);\n    \n      while (!openSet.isEmpty()) {\n        // find node with least f on open set\n        let currNode = openSet.pop();\n    \n        currNode.isVisited = true;\n        visited.push(currNode);\n    \n        if (currNode === endNode) {\n          return visited;\n        }\n    \n        let neighbours = getUnvisitedNeighbours(graph, currNode);\n        for (let neighbour of neighbours) {\n          if (currNode.distance + 1 < neighbour.distance) {\n            neighbour.predecessor = currNode;\n            neighbour.distance = currNode.distance + 1;\n    \n            // calculate manhattan distance heuristic for neighbour\n            let h =\n              Math.abs(neighbour.col - endNode.col) +\n              Math.abs(neighbour.row - endNode.row);\n            neighbour.f = h;\n    \n            openSet.push(neighbour);\n          }\n        }\n      }\n    \n      return visited;\n}","import React, { Component } from \"react\";\nimport NavBar from \"./components/navbar\";\nimport {\n  DIJKSTRAS_LABEL,\n  BFS_LABEL,\n  DFS_LABEL,\n  ASTAR_LABEL,\n  GREEDY_BEST_FIRST_LABEL,\n} from \"./components/navbar\";\nimport Legend from \"./components/legend\";\nimport Node from \"./components/node.jsx\";\nimport \"./PathfindingVisualizer.css\";\nimport { dijkstras, getShortestPath } from \"./algorithms/dijkstras\";\nimport { bfs } from \"./algorithms/bfs\";\nimport { dfs } from \"./algorithms/dfs\";\nimport { aStar } from \"./algorithms/aStar\";\nimport { greedyBestFirstSearch } from \"./algorithms/greedyBestFirstSearch\";\n\nconst START_NODE_X = 12;\nconst START_NODE_Y = 10;\nconst END_NODE_X = 30;\nconst END_NODE_Y = 10;\nconst NUM_COLS = 43;\nconst NUM_ROWS = 21;\nconst TIME = 0;\n\nclass PathfindingVisualizer extends Component {\n  state = {\n    nodes: [],\n    start: { x: START_NODE_X, y: START_NODE_Y },\n    end: { x: END_NODE_X, y: END_NODE_Y },\n    mouseIsPressed: false,\n    startIsPressed: false,\n    endIsPressed: false,\n    selectedAlgorithm: \"\",\n    legend: {\n      timeTaken: TIME.toFixed(3),\n      algorithmMessage: \"\",\n    },\n    isAnimating: false,\n  };\n\n  componentDidMount() {\n    const nodes = this.getInitialGraph();\n    this.setState({ nodes });\n  }\n\n  /**\n   * animates traversal of given algorithm on current graph state\n   * @param {*} algorithm algorithm to visualize\n   */\n  visualize(algorithm) {\n    this.resetNodesToUnvisited();\n\n    // deep copy of the state's nodes\n    const graph = this.state.nodes.map((col) => {\n      return col.map((node) => {\n        let newNode = {};\n        for (let key in node) {\n          newNode[key] = node[key];\n        }\n        return newNode;\n      });\n    });\n\n    const { start, end } = this.state;\n    const startNode = graph[start.x][start.y];\n    const endNode = graph[end.x][end.y];\n    const startTime = performance.now();\n\n    const visitedNodes = algorithm(graph, startNode, endNode);\n\n    // get time allotted for searching animation to finish\n    const endTime = performance.now();\n    const time = (endTime - startTime).toFixed(3);\n\n    // start animation of traversal\n    this.setState({ isAnimating: true });\n    // for each visited node:\n    // one extra iteration to animate path\n    for (let i = 0; i <= visitedNodes.length; i++) {\n      // if on last iteration, animate path\n      // timeout proportional to iteration number so path animates after visited nodes\n      if (i === visitedNodes.length) {\n        setTimeout(() => {\n          const shortestPath = getShortestPath(endNode);\n          this.animatePath(shortestPath);\n\n          setTimeout(() => {\n            this.setState({ nodes: graph, isAnimating: false });\n\n            this.setState({ legend: { timeTaken: time } });\n          }, 30 * shortestPath.length + 1200); /** delay until last iteration of path animation\n                                                plus amount of seconds to animate path node */\n        }, 15 * i + 500);\n\n        return;\n      }\n\n      let currNode = visitedNodes[i];\n      const { col, row } = currNode;\n      // animate each node to change colour one after another\n      // timeout based on position in list so that\n      // each node should only changes colour after the previously visited one has changed colour\n      setTimeout(() => {\n        document.getElementById(`node ${col} ${row}`).className +=\n          \" visited-animation\";\n      }, 15 * i);\n    }\n  }\n\n  /**\n   * animates the given shortest path nodes in order\n   * @param {*} shortestPath\n   */\n  animatePath(shortestPath) {\n    for (let i = 0; i < shortestPath.length; i++) {\n      let currNode = shortestPath[i];\n      const { col, row } = currNode;\n      setTimeout(() => {\n        document.getElementById(`node ${col} ${row}`).className +=\n          \" path-animation\";\n      }, 30 * i);\n    }\n  }\n\n  handleMouseDown = (x, y) => {\n    // don't allow user to edit board while animating an algorithm\n    if (this.state.isAnimating) {\n      return;\n    }\n\n    const graph = [...this.state.nodes];\n    const currNode = graph[x][y];\n    if (!currNode.isStart && !currNode.isEnd) {\n      this.setState({ mouseIsPressed: true });\n      this.toggleWall(currNode, graph);\n    } else {\n      if (currNode.isStart) {\n        this.setState({ mouseIsPressed: true, startIsPressed: true });\n      } else {\n        this.setState({ mouseIsPressed: true, endIsPressed: true });\n      }\n    }\n  };\n\n  handleMouseEnter = (x, y) => {\n    if (!this.state.mouseIsPressed) {\n      return;\n    }\n\n    const graph = [...this.state.nodes];\n    const currNode = graph[x][y];\n\n    if (this.state.startIsPressed) {\n      this.changeStartNode(currNode, graph);\n      return;\n    } else if (this.state.endIsPressed) {\n      this.changeEndNode(currNode, graph);\n      return;\n    }\n\n    this.toggleWall(currNode, graph);\n  };\n\n  handleMouseUp = () => {\n    // make sure that where start and end node are placed is not ON a wall\n    const nodes = [...this.state.nodes];\n    const { start, end } = this.state;\n    nodes[start.x][start.y].isWall = false;\n    nodes[end.x][end.y].isWall = false;\n\n    this.setState({\n      nodes,\n      mouseIsPressed: false,\n      startIsPressed: false,\n      endIsPressed: false,\n    });\n  };\n\n  setSelectedAlgorithm = (algorithm) => {\n    this.setState({ selectedAlgorithm: algorithm });\n  };\n\n  handleVisualize = () => {\n    const { selectedAlgorithm } = this.state;\n\n    switch (selectedAlgorithm) {\n      case DIJKSTRAS_LABEL:\n        this.visualize(dijkstras);\n        break;\n      case BFS_LABEL:\n        this.visualize(bfs);\n        break;\n      case DFS_LABEL:\n        this.visualize(dfs);\n        break;\n      case ASTAR_LABEL:\n        this.visualize(aStar);\n        break;\n      case GREEDY_BEST_FIRST_LABEL:\n        this.visualize(greedyBestFirstSearch);\n        break;\n      default:\n        alert(\"Select an algorithm to visualize!\");\n        return;\n    }\n  };\n\n  /**\n   * resets graph to the intial graph\n   */\n  handleReset = () => {\n    const nodes = this.getInitialGraph();\n    this.setState({\n      nodes,\n      start: { x: START_NODE_X, y: START_NODE_Y },\n      end: { x: END_NODE_X, y: END_NODE_Y },\n    });\n  };\n\n  /**\n   * clears all walls from graph without moving start and end nodes\n   */\n  clearWalls = () => {\n    const graph = [...this.state.nodes];\n    for (let x = 0; x < NUM_COLS; x++) {\n      for (let y = 0; y < NUM_ROWS; y++) {\n        let node = graph[x][y];\n        node.isWall = false;\n      }\n    }\n\n    this.setState({ nodes: graph });\n  };\n\n  render() {\n    return (\n      <React.Fragment>\n        <NavBar\n          setAlgorithm={this.setSelectedAlgorithm}\n          selectedAlgorithm={this.state.selectedAlgorithm}\n          onVisualize={this.handleVisualize}\n          onReset={this.handleReset}\n          onClearPath={this.resetNodesToUnvisited}\n          onClearWalls={this.clearWalls}\n          isAnimating={this.state.isAnimating}\n        />\n        <Legend legend={this.state.legend} />\n        <div className=\"grid\">\n          {this.state.nodes.map((col, colIdx) => (\n              <div key={colIdx}>\n                {col.map((node, rowIdx) => (\n                  <Node\n                    key={rowIdx}\n                    onMouseDown={this.handleMouseDown}\n                    onMouseEnter={this.handleMouseEnter}\n                    onMouseUp={this.handleMouseUp}\n                    isAnimating={this.state.isAnimating}\n                    col={node.col}\n                    row={node.row}\n                    isStart={node.isStart}\n                    isEnd={node.isEnd}\n                    isVisited={node.isVisited}\n                    isPath={node.isPath}\n                    isWall={node.isWall}\n                  />\n                ))}\n              </div>\n          ))}\n        </div>\n      </React.Fragment>\n    );\n  }\n\n  /**\n   * \ttoggles the given node at x,y on the graph as/not as a wall\n   * @param {*} currNode\n   * @param {*} graph\n   */\n  toggleWall(currNode, graph) {\n    if (currNode.isStart || currNode.isEnd) {\n      return;\n    }\n    // animate the wall/dewall animation\n    if (!currNode.isWall) {\n      document.getElementById(`node ${currNode.col} ${currNode.row}`).className +=\n      \" wall-animation\";\n    }else {\n      document.getElementById(`node ${currNode.col} ${currNode.row}`).className +=\n      \" dewall-animation\";\n    }\n\n    const newNode = {\n      ...currNode,\n      isWall: !currNode.isWall,\n    };\n    // set state after wall is done animating\n    setTimeout(() => {\n      graph[currNode.col][currNode.row] = newNode;\n      this.setState({ nodes: graph });\n    }, 200);\n  }\n\n  /**\n   * sets given node as the end node\n   * @param {*} currNode\n   * @param {*} graph\n   */\n  changeEndNode(currNode, graph) {\n    const { col, row } = currNode;\n    const { x, y } = this.state.end;\n    graph[x][y].isEnd = false;\n    currNode.isEnd = true;\n    // currNode.isWall = false;\n    this.setState({ nodes: graph, end: { x: col, y: row } });\n  }\n\n  /**\n   * sets given node as the start node\n   * @param {*} currNode\n   * @param {*} graph\n   */\n  changeStartNode(currNode, graph) {\n    const { col, row } = currNode;\n    const { x, y } = this.state.start;\n    graph[x][y].isStart = false;\n    currNode.isStart = true;\n    // currNode.isWall = false;\n    this.setState({ nodes: graph, start: { x: col, y: row } });\n  }\n\n  /**\n   * resets state's nodes to before search algorithm was called\n   */\n  resetNodesToUnvisited = () => {\n    const graph = [...this.state.nodes];\n    for (let x = 0; x < NUM_COLS; x++) {\n      for (let y = 0; y < NUM_ROWS; y++) {\n        let node = graph[x][y];\n        node.isVisited = false;\n        node.isPath = false;\n        node.distance = Infinity;\n        node.predecessor = null;\n      }\n    }\n\n    this.setState({ nodes: graph });\n  };\n\n  /**\n   * returns initial graph with no walls toggled or visited nodes\n   */\n  getInitialGraph() {\n    const nodes = [];\n\n    for (let col = 0; col < NUM_COLS; col++) {\n      const currCol = [];\n      for (let row = 0; row < NUM_ROWS; row++) {\n        const currNode = {\n          col,\n          row,\n          isStart: col === START_NODE_X && row === START_NODE_Y,\n          isEnd: col === END_NODE_X && row === END_NODE_Y,\n          isVisited: false,\n          isWall: false,\n          isPath: false,\n          distance: Infinity,\n          f: Infinity,\n          predecessor: null,\n        };\n        currCol.push(currNode);\n      }\n      nodes.push(currCol);\n    }\n    return nodes;\n  }\n}\n\nexport default PathfindingVisualizer;\n","import \"bootstrap/dist/css/bootstrap.min.css\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport PathfindingVisualizer from \"./PathfindingVisualizer\";\n\nReactDOM.render(<PathfindingVisualizer />, document.getElementById(\"root\"));\n"],"sourceRoot":""}