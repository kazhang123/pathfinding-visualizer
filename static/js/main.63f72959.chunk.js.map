{"version":3,"sources":["components/navbar.jsx","components/legend.jsx","components/node.jsx","algorithms/PriorityQueue.js","algorithms/dijkstras.js","algorithms/Queue.js","algorithms/bfs.js","algorithms/Stack.js","algorithms/dfs.js","algorithms/aStar.js","algorithms/greedyBestFirstSearch.js","PathfindingVisualizer.js","index.js"],"names":["NavBar","Navbar","collapseOnSelect","expand","bg","variant","Brand","href","Toggle","aria-controls","Collapse","id","Nav","className","NavDropdown","title","Item","onSelect","props","setAlgorithm","Button","disabled","this","isAnimating","onClick","onVisualize","selectedAlgorithm","onClearPath","onClearWalls","onClearWeights","onReset","isAddWeightSelected","setAddWeightSelected","Component","Legend","width","height","viewBox","class","fill","xmlns","style","fill-rule","d","key","legend","timeTaken","Node","classes","isStart","isEnd","isVisited","isWall","isPath","isWeighted","startEndNode","col","row","onMouseDown","onMouseEnter","onMouseUp","display","cursor","position","marginLeft","marginTop","getClasses","PureComponent","PriorityQueue","scoreFunction","heap","value","push","heapifyUp","length","min","pop","heapifyDown","idx","Math","floor","leftChild","currIdx","leftIdx","rightIdx","rightChild","hasAChild","minChildIdx","minChild","childScore","swap","parentIdx","parent","idxA","idxB","temp","dijkstras","graph","startNode","endNode","visited","pq","node","distance","isEmpty","currNode","neighbours","getUnvisitedNeighbours","neighbour","weight","predecessor","filter","n","Queue","elems","first","size","elem","front","splice","bfs","q","enqueue","dequeue","Stack","dfs","stack","aStar","openSet","f","h","abs","g","greedyBestFirstSearch","PathfindingVisualizer","state","nodes","start","x","y","end","mouseIsPressed","startIsPressed","endIsPressed","toFixed","algorithmMessage","handleMouseDown","setState","handleAddWeight","toggleWall","handleMouseEnter","changeStartNode","changeEndNode","handleMouseUp","newNode","setSelectedAlgorithm","algorithm","clearWeights","console","log","handleVisualize","visualize","alert","handleReset","getInitialGraph","clearWalls","resetNodesToUnvisited","Infinity","map","startTime","performance","now","visitedNodes","time","i","setTimeout","shortestPath","path","reverse","getShortestPath","animatePath","document","getElementById","Fragment","colIdx","rowIdx","currCol","ReactDOM","render"],"mappings":"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","file":"static/js/main.63f72959.chunk.js","sourcesContent":["import React, { Component } from \"react\";\nimport { Navbar, Nav, NavDropdown, Button } from \"react-bootstrap\";\n\nexport const DIJKSTRAS_LABEL = \"Dijkstra's\";\nexport const BFS_LABEL = \"BFS\";\nexport const DFS_LABEL = \"DFS\";\nexport const ASTAR_LABEL = \"A*\";\nexport const GREEDY_BEST_FIRST_LABEL = \"Greedy Best First Search\";\n\nclass NavBar extends Component {\n  render() {\n    return (\n      <Navbar collapseOnSelect expand=\"lg\" bg=\"light\" variant=\"light\">\n        <Navbar.Brand href=\"#home\">Pathfinding Visualizer</Navbar.Brand>\n        <Navbar.Toggle aria-controls=\"responsive-navbar-nav\" />\n        <Navbar.Collapse id=\"responsive-navbar-nav\">\n          <Nav className=\"mr-auto\">\n            <NavDropdown title=\"Algorithms\" id=\"collasible-nav-dropdown\">\n              <NavDropdown.Item\n                href=\"#action/3.1\"\n                onSelect={() => this.props.setAlgorithm(DIJKSTRAS_LABEL)}\n              >\n                Dijkstra's\n              </NavDropdown.Item>\n              <NavDropdown.Item\n                href=\"#action/3.2\"\n                onSelect={() => this.props.setAlgorithm(BFS_LABEL)}\n              >\n                Breadth First Search\n              </NavDropdown.Item>\n              <NavDropdown.Item\n                href=\"#action/3.3\"\n                onSelect={() => this.props.setAlgorithm(DFS_LABEL)}\n              >\n                Depth First Search\n              </NavDropdown.Item>\n              <NavDropdown.Item\n                href=\"#action/3.4\"\n                onSelect={() => this.props.setAlgorithm(GREEDY_BEST_FIRST_LABEL)}\n              >\n                Greedy Best First Search\n              </NavDropdown.Item>\n              <NavDropdown.Item\n                href=\"#action/3.5\"\n                onSelect={() => this.props.setAlgorithm(ASTAR_LABEL)}\n              >\n                A*\n              </NavDropdown.Item>\n            </NavDropdown>\n            <span>\n              <Button variant=\"info\" disabled={this.props.isAnimating} onClick={this.props.onVisualize}>\n                {`Visualize ${this.props.selectedAlgorithm}`}\n              </Button>{\" \"}\n            </span>\n            <Button variant=\"light\" disabled={this.props.isAnimating} onClick={this.props.onClearPath}>\n              Clear Path\n            </Button>{\" \"}\n            <Button variant=\"light\" disabled={this.props.isAnimating} onClick={this.props.onClearWalls}>\n              Clear Walls\n            </Button>{\" \"}\n            <Button variant=\"light\" disabled={this.props.isAnimating} onClick={this.props.onClearWeights}>\n              Clear Weights\n            </Button>\n            <Button variant=\"light\" disabled={this.props.isAnimating} onClick={this.props.onReset}>\n              Reset\n            </Button>\n            <Button \n              variant={this.props.isAddWeightSelected ? \"dark\" : \"outline-dark\"} \n              disabled={this.props.isAnimating || this.props.selectedAlgorithm == BFS_LABEL || this.props.selectedAlgorithm == DFS_LABEL} \n              onClick={this.props.setAddWeightSelected}>\n              {this.props.isAddWeightSelected ? \"Stop Adding Weights\" : \"Add Weights\"}\n            </Button>\n          </Nav>\n        </Navbar.Collapse>\n      </Navbar>\n    );\n  }\n}\n\nexport default NavBar;\n","import React, { Component } from \"react\";\nimport \"./legend.css\";\n\nclass Legend extends Component {\n  render() {\n    return (\n      <div className=\"legend\">\n        <span className=\"legend-item block black\"></span>\n        <span className=\"legend-item\">Wall</span>\n        <span className=\"legend-item block green\"></span>\n        <span className=\"legend-item\">Visited node</span>\n        <span className=\"legend-item block yellow\"></span>\n        <span className=\"legend-item\">Path</span>\n        <span>\n          <span id=\"startSymbol\" className=\"legend-item\"></span>\n          <span className=\"legend-item\">Start node</span>\n        </span>\n        <span>\n          <svg\n            width=\"2em\"\n            height=\"2em\"\n            viewBox=\"0 0 16 16\"\n            class=\"bi bi-asterisk ml-2\"\n            fill=\"currentColor\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n            style={{ width: \"26px\", height: \"26px\" }}\n          >\n            <path\n              fill-rule=\"evenodd\"\n              d=\"M8 0a1 1 0 0 1 1 1v5.268l4.562-2.634a1 1 0 1 1 1 1.732L10 8l4.562 2.634a1 1 0 1 1-1 1.732L9 9.732V15a1 1 0 1 1-2 0V9.732l-4.562 2.634a1 1 0 1 1-1-1.732L6 8 1.438 5.366a1 1 0 0 1 1-1.732L7 6.268V1a1 1 0 0 1 1-1z\"\n            />\n          </svg>\n          <span className=\"legend-item\">End node</span>\n        </span>\n        <span className=\"legend-item weight\"/>\n        <span className=\"legend-item\">Weighted Node</span>\n        <span className=\"legend-item time\">\n          <svg\n            width=\"1em\"\n            height=\"1em\"\n            viewBox=\"0 0 16 16\"\n            class=\"bi bi-clock m-2\"\n            fill=\"currentColor\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n          >\n            <path\n              fill-rule=\"evenodd\"\n              d=\"M8 15A7 7 0 1 0 8 1a7 7 0 0 0 0 14zm8-7A8 8 0 1 1 0 8a8 8 0 0 1 16 0z\"\n            />\n            <path\n              fill-rule=\"evenodd\"\n              d=\"M7.5 3a.5.5 0 0 1 .5.5v5.21l3.248 1.856a.5.5 0 0 1-.496.868l-3.5-2A.5.5 0 0 1 7 9V3.5a.5.5 0 0 1 .5-.5z\"\n            />\n          </svg>\n          <span\n            className=\"legend-item time\"\n            key={this.props.legend.timeTaken}\n          >{`${this.props.legend.timeTaken} ms to find path`}</span>\n        </span>\n      </div>\n    );\n  }\n}\n\nexport default Legend;\n","import React, { Component } from \"react\";\nimport { PureComponent } from \"react\";\nimport \"./node.css\";\n\nclass Node extends PureComponent {\n  getClasses() {\n    let classes = \"node \";\n    const {\n      isStart,\n      isEnd,\n      isVisited,\n      isWall,\n      isPath,\n      isAnimating,\n      isWeighted,\n    } = this.props;\n\n    classes += isStart\n      ? \"start\"\n      : isEnd\n      ? \"end\"\n      : isWall\n      ? \"wall\"\n      : isWeighted\n      ? \"weight\" \n      : \"\";\n\n    // if not currently animating nodes, keep nodes stagnant colours\n    if (!isAnimating) {\n      if (isPath) {\n        classes = \"path \" + classes;\n      } else if (isVisited) {\n        classes = \"visited \" + classes;\n      }\n    }\n\n    return classes;\n  }\n\n  render() {\n    // console.log(\"rendered\")\n    const { col, row, isStart, isEnd, isWeighted } = this.props;\n\n    // if node is start/end, render specific symbol on top of the node\n    let startEndNode;\n\n    if (isStart) {\n      startEndNode = (\n        <div\n          className=\"startWrap\"\n          onMouseDown={() => this.props.onMouseDown(col, row)}\n          onMouseEnter={() => this.props.onMouseEnter(col, row)}\n          onMouseUp={() => this.props.onMouseUp()}\n        ></div>\n      );\n    } else if (isEnd) {\n      startEndNode = (\n        <svg\n          width=\"1em\"\n          height=\"1em\"\n          viewBox=\"0 0 16 16\"\n          class=\"bi bi-asterisk \"\n          style={{\n            width: \"24px\",\n            height: \"24px\",\n            display: \"block\",\n            cursor: \"pointer\",\n            position: \"absolute\",\n            marginLeft: \"2px\",\n            marginTop: \"2px\",\n          }}\n          fill=\"currentColor\"\n          xmlns=\"http://www.w3.org/2000/svg\"\n          onMouseDown={() => this.props.onMouseDown(col, row)}\n          onMouseEnter={() => this.props.onMouseEnter(col, row)}\n          onMouseUp={() => this.props.onMouseUp()}\n        >\n          <path\n            fill-rule=\"evenodd\"\n            d=\"M8 0a1 1 0 0 1 1 1v5.268l4.562-2.634a1 1 0 1 1 1 1.732L10 8l4.562 2.634a1 1 0 1 1-1 1.732L9 9.732V15a1 1 0 1 1-2 0V9.732l-4.562 2.634a1 1 0 1 1-1-1.732L6 8 1.438 5.366a1 1 0 0 1 1-1.732L7 6.268V1a1 1 0 0 1 1-1z\"\n          />\n        </svg>\n      );\n    }\n\n    return (\n      <div className=\"wrap\">\n        {startEndNode}\n        <div\n          onMouseDown={() => this.props.onMouseDown(col, row)}\n          onMouseEnter={() => this.props.onMouseEnter(col, row)}\n          onMouseUp={() => this.props.onMouseUp()}\n          className={this.getClasses()}\n          id={`node ${col} ${row}`}\n        ></div>\n      </div>\n    );\n  }\n}\n\nexport default Node;\n","export default class PriorityQueue {\n  constructor(scoreFunction) {\n    this.heap = [null];\n    this.scoreFunction = scoreFunction;\n  }\n\n  /**\n   * pushes value into priority queue\n   * @param {*} value \n   */\n  push(value) {\n    this.heap.push(value);\n    this.heapifyUp(this.heap.length - 1);\n  }\n\n  /**\n   * returns and removes minimum value in priority queue\n   */\n  pop() {\n    const min = this.heap[1];\n    this.heap[1] = this.heap[this.heap.length - 1];\n    this.heap.pop();\n    this.heapifyDown(1);\n    return min;\n  }\n\n  /**\n   * returns true if priority queue is empty\n   */\n  isEmpty() {\n    return this.heap.length === 1;\n  }\n\n  /**\n   * returns minimum value without removing it from priority queue\n   */\n  peek() {\n    const min = this.heap[1];\n    return min;\n  }\n\n  /**\n   * returns index of the left child of element at given index\n   * @param {*} idx \n   */\n  leftChild(idx) {\n    return 2 * idx;\n  }\n\n  /**\n   * returns index of right child of element at given index\n   * @param {*} idx \n   */\n  rightChild(idx) {\n    return 2 * idx + 1;\n  }\n\n  /**\n   * returns index of parent of element at given index\n   * @param {*} idx \n   */\n  parent(idx) {\n    return Math.floor(idx / 2);\n  }\n\n  /**\n   * returns true if element at given index has a child\n   * @param {*} idx \n   */\n  hasAChild(idx) {\n    return this.leftChild(idx) < this.heap.length;\n  }\n\n  /**\n   * returns the child of the current index with the lowest score\n   * assume function will be called only if currIdx has a child\n   * @param {*} currIdx\n   */\n  minChild(currIdx) {\n    const leftIdx = this.leftChild(currIdx);\n    const rightIdx = this.rightChild(currIdx);\n\n    // if no right child, then return left child\n    if (rightIdx >= this.heap.length) {\n      return leftIdx;\n    }\n\n    const leftScore = this.scoreFunction(this.heap[leftIdx]);\n    const rightScore = this.scoreFunction(this.heap[rightIdx]);\n\n    if (leftScore < rightScore) {\n      return leftIdx;\n    }\n\n    return rightIdx;\n  }\n\n  /**\n   * restores heap order by swapping down from given index until all children \n   * are larger than parents.\n   * @param {*} currIdx \n   */\n  heapifyDown(currIdx) {\n    if (this.hasAChild(currIdx)) {\n      const minChildIdx = this.minChild(currIdx);\n\n      const childScore = this.scoreFunction(this.heap[minChildIdx]);\n      const currScore = this.scoreFunction(this.heap[currIdx]);\n\n      if (currScore > childScore) {\n        this.swap(currIdx, minChildIdx);\n        this.heapifyDown(minChildIdx);\n      }\n    }\n  }\n\n  /**\n   * restores heap order by swapping up from given index until all children \n   * are larger than parents\n   * @param {*} currIdx \n   */\n  heapifyUp(currIdx) {\n    if (currIdx === 1) {\n      return;\n    }\n\n    const parentIdx = this.parent(currIdx);\n\n    const currScore = this.scoreFunction(this.heap[currIdx]);\n    const parentScore = this.scoreFunction(this.heap[parentIdx]);\n\n    if (currScore < parentScore) {\n      this.swap(currIdx, parentIdx);\n      this.heapifyUp(parentIdx);\n    }\n  }\n\n  /**\n   * swap elements at idxA and idxB in the priority queue\n   * @param {*} idxA \n   * @param {*} idxB \n   */\n  swap(idxA, idxB) {\n    let temp = this.heap[idxA];\n    this.heap[idxA] = this.heap[idxB];\n    this.heap[idxB] = temp;\n  }\n}\n","import PriorityQueue from \"./PriorityQueue\";\n\nexport function dijkstras(graph, startNode, endNode) {\n  // track visited nodes in order\n  let visited = [];\n\n  let pq = new PriorityQueue(function (node) {\n    return node.distance;\n  });\n\n  // initialize source\n  startNode.distance = 0;\n  pq.push(startNode);\n  // start at source node\n\n  while (!pq.isEmpty()) {\n    let currNode = pq.pop();\n    // console.log(currNode);\n\n    const { col, row } = currNode;\n\n    currNode.isVisited = true;\n    visited.push(currNode);\n    // if current node is end node, we are done searching\n    if (currNode === endNode) {\n      return visited;\n    }\n\n    // for each unvisited neighbour:\n    let neighbours = getUnvisitedNeighbours(graph, currNode);\n    for (let neighbour of neighbours) {\n      // update distance from start node and predecessor\n      if (currNode.distance + neighbour.weight < neighbour.distance) {\n        neighbour.distance = currNode.distance + neighbour.weight;\n        neighbour.predecessor = currNode;\n        pq.push(neighbour);\n      }\n    }\n  }\n\n  return visited;\n}\n\n/*\nreturns shortest path from startNode to endNode\n*/\nexport function getShortestPath(endNode) {\n  const path = [];\n\n  // If there is no path to the endNode i.e the endNode does not have a predecessor\n  if (endNode.predecessor === null) {\n    return [];\n  }\n\n  let currNode = endNode;\n  while (currNode !== null) {\n    currNode.isPath = true;\n    path.push(currNode);\n    currNode = currNode.predecessor;\n  }\n\n  return path.reverse();\n}\n\n/*\nreturns unvisited, non-wall neighbours (N, E, S, W) of given node \n*/\nexport function getUnvisitedNeighbours(graph, node) {\n  const neighbours = [];\n  const { col, row } = node;\n  if (row > 0) neighbours.push(graph[col][row - 1]);\n  if (col < graph.length - 1) neighbours.push(graph[col + 1][row]);\n  if (row < graph[0].length - 1) neighbours.push(graph[col][row + 1]);\n  if (col > 0) neighbours.push(graph[col - 1][row]);\n\n  return neighbours.filter((n) => !n.isVisited && !n.isWall);\n}\n","export default class Queue {\n  constructor() {\n    this.elems = [];\n    this.first = 0; // index of first element in array\n    this.size = 0; // number of items in array\n  }\n\n  /**\n   * pushes given object to end of queue\n   * @param {*} elem\n   */\n  enqueue(elem) {\n    this.elems.push(elem);\n    this.size++;\n  }\n\n  /**\n   * returns and removes object at front of queue\n   * resizes array downward when elements can fit into the first\n   * 0...k-1 indices of the array to achieve O(1) amortized runtime\n   *\n   * assume function will not be called on an empty queue\n   */\n  dequeue() {\n    const front = this.elems[this.first];\n    this.elems[this.first] = null;\n    this.first++;\n    this.size--;\n\n    if (!this.isEmpty() && this.size === this.first) {\n      this.elems.splice(0, this.first);\n      this.first = 0;\n    }\n\n    return front;\n  }\n\n  /**\n   * returns whether queue is empty\n   */\n  isEmpty() {\n    return this.size === 0;\n  }\n\n  /**\n   * returns object at front of queue without removing it\n   */\n  front() {\n    return this.elems[this.first];\n  }\n\n}\n","import Queue from \"./Queue\";\nimport { getUnvisitedNeighbours } from \"./dijkstras\";\n\nexport function bfs(graph, startNode, endNode) {\n  const q = new Queue();\n  const visited = [];\n\n  q.enqueue(startNode);\n  visited.push(startNode);\n  startNode.isVisited = true;\n\n  while (!q.isEmpty()) {\n    let currNode = q.dequeue();\n\n    let neighbours = getUnvisitedNeighbours(graph, currNode);\n    for (let neighbour of neighbours) {\n      neighbour.isVisited = true;\n      visited.push(neighbour);\n      neighbour.predecessor = currNode;\n\n      if (neighbour === endNode) {\n        return visited;\n      }\n\n      q.enqueue(neighbour);\n    }\n  }\n\n  return visited;\n}\n","export default class Stack {\n  constructor() {\n    this.elems = [];\n  }\n\n  /**\n   * pushes elem to top of stack\n   * @param {*} elem \n   */\n  push(elem) {\n    this.elems.push(elem);\n  }\n\n  /**\n   * returns and removes elem on top of stack\n   */\n  pop() {\n    return this.elems.pop();\n  }\n\n  /**\n   * returns true if stack is empty\n   */\n  isEmpty() {\n    return this.elems.length === 0;\n  }\n\n  /**\n   * returns elem on top of stack without removing it\n   */\n  peek() {\n    return this.elems[this.elems.length - 1];\n  }\n}\n","import Stack from \"./Stack\";\nimport { getUnvisitedNeighbours } from \"./dijkstras\";\n\nexport function dfs(graph, startNode, endNode) {\n  const stack = new Stack();\n  const visited = [];\n\n  stack.push(startNode);\n  visited.push(startNode);\n  startNode.isVisited = true;\n\n  while (!stack.isEmpty()) {\n    let currNode = stack.pop();\n\n    let neighbours = getUnvisitedNeighbours(graph, currNode);\n    for (let neighbour of neighbours) {\n      neighbour.isVisited = true;\n      visited.push(neighbour);\n      neighbour.predecessor = currNode;\n\n      if (neighbour === endNode) {\n        return visited;\n      }\n\n      stack.push(neighbour);\n    }\n  }\n\n  return visited;\n}\n","import PriorityQueue from \"./PriorityQueue\";\nimport { getUnvisitedNeighbours } from \"./dijkstras\";\n\nexport function aStar(graph, startNode, endNode) {\n  const openSet = new PriorityQueue(function (node) {\n    return node.f;\n  });\n\n  const visited = []; // closed set\n\n  // initialize open set\n  startNode.f = 0;\n  startNode.distance = 0;\n  openSet.push(startNode);\n\n  while (!openSet.isEmpty()) {\n    // find node with least f on open set\n    let currNode = openSet.pop();\n\n    currNode.isVisited = true;\n    visited.push(currNode);\n\n    if (currNode === endNode) {\n      return visited;\n    }\n\n    let neighbours = getUnvisitedNeighbours(graph, currNode);\n    for (let neighbour of neighbours) {\n      if (currNode.distance + neighbour.weight < neighbour.distance) {\n        neighbour.predecessor = currNode;\n        neighbour.distance = currNode.distance + neighbour.weight;\n\n        // calculate manhattan distance heuristic for neighbour\n        let h =\n          Math.abs(neighbour.col - endNode.col) +\n          Math.abs(neighbour.row - endNode.row);\n        let g = neighbour.distance;\n        neighbour.f = g + h;\n\n        openSet.push(neighbour);\n      }\n    }\n  }\n\n  return visited;\n}\n","import PriorityQueue from \"./PriorityQueue\";\nimport { getUnvisitedNeighbours } from \"./dijkstras\";\n\nexport function greedyBestFirstSearch(graph, startNode, endNode) {\n    const openSet = new PriorityQueue(function (node) {\n        return node.f;\n      });\n    \n      const visited = []; // closed set\n    \n      // initialize open set\n      startNode.f = 0;\n      startNode.distance = 0;\n      openSet.push(startNode);\n    \n      while (!openSet.isEmpty()) {\n        // find node with least f on open set\n        let currNode = openSet.pop();\n    \n        currNode.isVisited = true;\n        visited.push(currNode);\n    \n        if (currNode === endNode) {\n          return visited;\n        }\n    \n        let neighbours = getUnvisitedNeighbours(graph, currNode);\n        for (let neighbour of neighbours) {\n          if (currNode.distance + neighbour.weight < neighbour.distance) {\n            neighbour.predecessor = currNode;\n            neighbour.distance = currNode.distance + neighbour.weight;\n    \n            // calculate manhattan distance heuristic for neighbour\n            let h =\n              Math.abs(neighbour.col - endNode.col) +\n              Math.abs(neighbour.row - endNode.row);\n            neighbour.f = h;\n    \n            openSet.push(neighbour);\n          }\n        }\n      }\n    \n      return visited;\n}","import React, { Component } from \"react\";\nimport NavBar from \"./components/navbar\";\nimport {\n  DIJKSTRAS_LABEL,\n  BFS_LABEL,\n  DFS_LABEL,\n  ASTAR_LABEL,\n  GREEDY_BEST_FIRST_LABEL,\n} from \"./components/navbar\";\nimport Legend from \"./components/legend\";\nimport Node from \"./components/node.jsx\";\nimport \"./PathfindingVisualizer.css\";\nimport { dijkstras, getShortestPath } from \"./algorithms/dijkstras\";\nimport { bfs } from \"./algorithms/bfs\";\nimport { dfs } from \"./algorithms/dfs\";\nimport { aStar } from \"./algorithms/aStar\";\nimport { greedyBestFirstSearch } from \"./algorithms/greedyBestFirstSearch\";\n\nconst START_NODE_X = 12;\nconst START_NODE_Y = 10;\nconst END_NODE_X = 30;\nconst END_NODE_Y = 10;\nconst NUM_COLS = 43;\nconst NUM_ROWS = 21;\nconst TIME = 0;\nconst NODE_WEIGHT = 5;\n\nclass PathfindingVisualizer extends Component {\n  state = {\n    nodes: [],\n    start: { x: START_NODE_X, y: START_NODE_Y },\n    end: { x: END_NODE_X, y: END_NODE_Y },\n    mouseIsPressed: false,\n    startIsPressed: false,\n    endIsPressed: false,\n    selectedAlgorithm: \"\",\n    legend: {\n      timeTaken: TIME.toFixed(3),\n      algorithmMessage: \"\",\n    },\n    isAnimating: false,\n    isAddWeightSelected: false,\n  };\n\n  componentDidMount() {\n    const nodes = this.getInitialGraph();\n    this.setState({ nodes });\n  }\n\n  /**\n   * animates traversal of given algorithm on current graph state\n   * @param {*} algorithm algorithm to visualize\n   */\n  visualize(algorithm) {\n    this.resetNodesToUnvisited();\n\n    // deep copy of the state's nodes\n    const graph = this.state.nodes.map((col) => {\n      return col.map((node) => {\n        let newNode = {};\n        for (let key in node) {\n          newNode[key] = node[key];\n        }\n        return newNode;\n      });\n    });\n\n    const { start, end } = this.state;\n    const startNode = graph[start.x][start.y];\n    const endNode = graph[end.x][end.y];\n    const startTime = performance.now();\n\n    const visitedNodes = algorithm(graph, startNode, endNode);\n\n    // get time allotted for searching animation to finish\n    const endTime = performance.now();\n    const time = (endTime - startTime).toFixed(3);\n\n    // start animation of traversal\n    this.setState({ isAnimating: true });\n    // for each visited node:\n    // one extra iteration to animate path\n    for (let i = 0; i <= visitedNodes.length; i++) {\n      // if on last iteration, animate path\n      // timeout proportional to iteration number so path animates after visited nodes\n      if (i === visitedNodes.length) {\n        setTimeout(() => {\n          const shortestPath = getShortestPath(endNode);\n          this.animatePath(shortestPath);\n\n          setTimeout(() => {\n            this.setState({ nodes: graph, isAnimating: false });\n\n            this.setState({ legend: { timeTaken: time } });\n          }, 30 * shortestPath.length + 1200); /** delay until last iteration of path animation\n                                                plus amount of seconds to animate path node */\n        }, 15 * i + 500);\n\n        return;\n      }\n\n      let currNode = visitedNodes[i];\n      const { col, row } = currNode;\n      // animate each node to change colour one after another\n      // timeout based on position in list so that\n      // each node should only changes colour after the previously visited one has changed colour\n      setTimeout(() => {\n        document.getElementById(`node ${col} ${row}`).className +=\n          \" visited-animation\";\n      }, 15 * i);\n    }\n  }\n\n  /**\n   * animates the given shortest path nodes in order\n   * @param {*} shortestPath\n   */\n  animatePath(shortestPath) {\n    for (let i = 0; i < shortestPath.length; i++) {\n      let currNode = shortestPath[i];\n      const { col, row } = currNode;\n      setTimeout(() => {\n        document.getElementById(`node ${col} ${row}`).className +=\n          \" path-animation\";\n      }, 30 * i);\n    }\n  }\n\n  handleMouseDown = (x, y) => {\n    // don't allow user to edit board while animating an algorithm\n    if (this.state.isAnimating) {\n      return;\n    }\n\n    const graph = [...this.state.nodes];\n    const currNode = graph[x][y];\n\n    this.setState({mouseIsPressed: true});\n\n    if (currNode.isStart) {\n      this.setState({ startIsPressed: true });\n      return;\n    } \n    if (currNode.isEnd) {\n      this.setState({ endIsPressed: true });\n      return;\n    }\n\n    if (this.state.isAddWeightSelected) {\n      this.handleAddWeight(x, y);\n      return;\n    }\n\n    this.toggleWall(currNode, graph);\n  };\n\n  handleMouseEnter = (x, y) => {\n    if (!this.state.mouseIsPressed) {\n      return;\n    }\n\n    const graph = [...this.state.nodes];\n    const currNode = graph[x][y];\n\n    if (this.state.startIsPressed) {\n      this.changeStartNode(currNode, graph);\n      return;\n    } else if (this.state.endIsPressed) {\n      this.changeEndNode(currNode, graph);\n      return;\n    }\n\n    if (this.state.isAddWeightSelected) {\n      this.handleAddWeight(x, y);\n      return;\n    }\n\n    this.toggleWall(currNode, graph);\n  };\n\n  handleMouseUp = () => {\n    // make sure that where start and end node are placed is not ON a wall\n    const nodes = [...this.state.nodes];\n    const { start, end } = this.state;\n    nodes[start.x][start.y].isWall = false;\n    nodes[end.x][end.y].isWall = false;\n\n    this.setState({\n      nodes,\n      mouseIsPressed: false,\n      startIsPressed: false,\n      endIsPressed: false,\n    });\n  };\n\n  handleAddWeight = (x, y) => {\n    const graph = [...this.state.nodes];\n    const currNode = graph[x][y];\n  \n    let newNode;\n    if (currNode.isWeighted) {\n      newNode = {\n        ...currNode,\n        weight: 1,\n        isWeighted: false,\n      }\n    } else {\n      newNode = {\n        ...currNode,\n        weight: NODE_WEIGHT,\n        isWeighted: true,\n      }\n    }\n  \n    graph[x][y] = newNode;\n    this.setState({nodes: graph});\n  };\n\n  setSelectedAlgorithm = (algorithm) => {\n    if (algorithm == BFS_LABEL || algorithm == DFS_LABEL) {\n      this.clearWeights();\n    }\n    this.setState({ selectedAlgorithm: algorithm });\n  };\n\n  setAddWeightSelected = () => {\n    this.setState({isAddWeightSelected: !this.state.isAddWeightSelected});\n    console.log(\"add weight is selected: \" + this.state.isAddWeightSelected);\n  };\n\n  handleVisualize = () => {\n    const { selectedAlgorithm } = this.state;\n\n    switch (selectedAlgorithm) {\n      case DIJKSTRAS_LABEL:\n        this.visualize(dijkstras);\n        break;\n      case BFS_LABEL:\n        this.visualize(bfs);\n        break;\n      case DFS_LABEL:\n        this.visualize(dfs);\n        break;\n      case ASTAR_LABEL:\n        this.visualize(aStar);\n        break;\n      case GREEDY_BEST_FIRST_LABEL:\n        this.visualize(greedyBestFirstSearch);\n        break;\n      default:\n        alert(\"Select an algorithm to visualize!\");\n        return;\n    }\n  };\n\n  /**\n   * resets graph to the intial graph\n   */\n  handleReset = () => {\n    const nodes = this.getInitialGraph();\n    this.setState({\n      nodes,\n      start: { x: START_NODE_X, y: START_NODE_Y },\n      end: { x: END_NODE_X, y: END_NODE_Y },\n    });\n  };\n\n  /**\n   * clears all walls from graph without moving start and end nodes\n   */\n  clearWalls = () => {\n    const graph = [...this.state.nodes];\n    for (let x = 0; x < NUM_COLS; x++) {\n      for (let y = 0; y < NUM_ROWS; y++) {\n        let node = graph[x][y];\n        node.isWall = false;\n      }\n    }\n\n    this.setState({ nodes: graph });\n  };\n\n  /**\n   * clears all weights from graph without affecting walls or start/end nodes\n   */\n  clearWeights = () => {\n    const graph = [...this.state.nodes];\n    for (let x = 0; x < NUM_COLS; x++) {\n      for (let y = 0; y < NUM_ROWS; y++) {\n        let node = graph[x][y];\n        node.isWeighted = false;\n        node.weight = 1;\n      }\n    }\n\n    this.setState({ nodes: graph });\n  }\n\n  render() {\n    return (\n      <React.Fragment>\n        <NavBar\n          setAlgorithm={this.setSelectedAlgorithm}\n          selectedAlgorithm={this.state.selectedAlgorithm}\n          onVisualize={this.handleVisualize}\n          onReset={this.handleReset}\n          onClearPath={this.resetNodesToUnvisited}\n          onClearWalls={this.clearWalls}\n          onClearWeights={this.clearWeights}\n          isAnimating={this.state.isAnimating}\n          setAddWeightSelected={this.setAddWeightSelected}\n          isAddWeightSelected={this.state.isAddWeightSelected}\n        />\n        <Legend legend={this.state.legend} />\n        <div className=\"grid\">\n          {this.state.nodes.map((col, colIdx) => (\n              <div key={colIdx}>\n                {col.map((node, rowIdx) => (\n                  <Node\n                    key={rowIdx}\n                    onMouseDown={this.handleMouseDown}\n                    onMouseEnter={this.handleMouseEnter}\n                    onMouseUp={this.handleMouseUp}\n                    isAnimating={this.state.isAnimating}\n                    col={node.col}\n                    row={node.row}\n                    isStart={node.isStart}\n                    isEnd={node.isEnd}\n                    isVisited={node.isVisited}\n                    isPath={node.isPath}\n                    isWall={node.isWall}\n                    isWeighted={node.isWeighted}\n                  />\n                ))}\n              </div>\n          ))}\n        </div>\n      </React.Fragment>\n    );\n  }\n\n  /**\n   * \ttoggles the given node at x,y on the graph as/not as a wall\n   * @param {*} currNode\n   * @param {*} graph\n   */\n  toggleWall(currNode, graph) {\n    if (currNode.isStart || currNode.isEnd) {\n      return;\n    }\n    // animate the wall/dewall animation\n    if (!currNode.isWall) {\n      document.getElementById(`node ${currNode.col} ${currNode.row}`).className +=\n      \" wall-animation\";\n    }else {\n      document.getElementById(`node ${currNode.col} ${currNode.row}`).className +=\n      \" dewall-animation\";\n    }\n\n    const newNode = {\n      ...currNode,\n      isWall: !currNode.isWall,\n    };\n    // set state after wall is done animating\n    setTimeout(() => {\n      graph[currNode.col][currNode.row] = newNode;\n      this.setState({ nodes: graph });\n    }, 200);\n  }\n\n  /**\n   * sets given node as the end node\n   * @param {*} currNode\n   * @param {*} graph\n   */\n  changeEndNode(currNode, graph) {\n    const { col, row } = currNode;\n    const { x, y } = this.state.end;\n    graph[x][y].isEnd = false;\n    currNode.isEnd = true;\n    // currNode.isWall = false;\n    this.setState({ nodes: graph, end: { x: col, y: row } });\n  }\n\n  /**\n   * sets given node as the start node\n   * @param {*} currNode\n   * @param {*} graph\n   */\n  changeStartNode(currNode, graph) {\n    const { col, row } = currNode;\n    const { x, y } = this.state.start;\n    graph[x][y].isStart = false;\n    currNode.isStart = true;\n    // currNode.isWall = false;\n    this.setState({ nodes: graph, start: { x: col, y: row } });\n  }\n\n  /**\n   * resets state's nodes to before search algorithm was called\n   */\n  resetNodesToUnvisited = () => {\n    const graph = [...this.state.nodes];\n    for (let x = 0; x < NUM_COLS; x++) {\n      for (let y = 0; y < NUM_ROWS; y++) {\n        let node = graph[x][y];\n        node.isVisited = false;\n        node.isPath = false;\n        node.distance = Infinity;\n        node.predecessor = null;\n      }\n    }\n\n    this.setState({ nodes: graph });\n  };\n\n  /**\n   * returns initial graph with no walls toggled or visited nodes\n   */\n  getInitialGraph() {\n    const nodes = [];\n\n    for (let col = 0; col < NUM_COLS; col++) {\n      const currCol = [];\n      for (let row = 0; row < NUM_ROWS; row++) {\n        const currNode = {\n          col,\n          row,\n          isStart: col === START_NODE_X && row === START_NODE_Y,\n          isEnd: col === END_NODE_X && row === END_NODE_Y,\n          isVisited: false,\n          isWall: false,\n          isPath: false,\n          distance: Infinity,\n          f: Infinity,\n          predecessor: null,\n          weight: 1,\n          isWeighted: false,\n        };\n        currCol.push(currNode);\n      }\n      nodes.push(currCol);\n    }\n    return nodes;\n  }\n}\n\nexport default PathfindingVisualizer;\n","import \"bootstrap/dist/css/bootstrap.min.css\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport PathfindingVisualizer from \"./PathfindingVisualizer\";\n\nReactDOM.render(<PathfindingVisualizer />, document.getElementById(\"root\"));\n"],"sourceRoot":""}