{"version":3,"sources":["components/navbar.jsx","components/legend.jsx","components/node.jsx","algorithms/PriorityQueue.js","algorithms/dijkstras.js","algorithms/Queue.js","algorithms/bfs.js","algorithms/Stack.js","algorithms/dfs.js","algorithms/aStar.js","algorithms/greedyBestFirstSearch.js","PathfindingVisualizer.js","index.js"],"names":["NavBar","Navbar","collapseOnSelect","expand","bg","variant","Brand","href","Toggle","aria-controls","Collapse","id","Nav","className","NavDropdown","title","Item","onSelect","props","setAlgorithm","Button","onClick","this","onVisualize","selectedAlgorithm","onClearPath","onClearWalls","onReset","Component","Legend","width","height","viewBox","class","fill","xmlns","style","fill-rule","d","key","legend","timeTaken","Node","classes","node","isStart","isEnd","isVisited","isWall","isPath","isAnimating","startEndNode","col","row","onMouseDown","onMouseEnter","onMouseUp","display","cursor","position","marginLeft","marginTop","getClasses","PriorityQueue","scoreFunction","heap","value","push","heapifyUp","length","min","pop","heapifyDown","idx","Math","floor","leftChild","currIdx","leftIdx","rightIdx","rightChild","hasAChild","minChildIdx","minChild","childScore","swap","parentIdx","parent","idxA","idxB","temp","dijkstras","graph","startNode","endNode","visited","pq","distance","isEmpty","currNode","neighbours","getUnvisitedNeighbours","neighbour","predecessor","filter","n","Queue","elems","first","size","elem","front","splice","bfs","q","enqueue","dequeue","Stack","dfs","stack","aStar","openSet","f","h","abs","g","greedyBestFirstSearch","PathfindingVisualizer","state","nodes","start","x","y","end","mouseIsPressed","startIsPressed","endIsPressed","toFixed","algorithmMessage","handleMouseDown","setState","toggleWall","handleMouseEnter","changeStartNode","changeEndNode","handleMouseUp","setSelectedAlgorithm","algorithm","handleVisualize","visualize","alert","handleReset","getInitialGraph","clearWalls","resetNodesToUnvisited","Infinity","map","newNode","startTime","performance","now","visitedNodes","time","i","setTimeout","shortestPath","path","reverse","getShortestPath","animatePath","document","getElementById","Fragment","Date","colIdx","rowIdx","currCol","ReactDOM","render"],"mappings":"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","file":"static/js/main.7c0f92a8.chunk.js","sourcesContent":["import React, { Component } from \"react\";\nimport { Navbar, Nav, NavDropdown, Button } from \"react-bootstrap\";\n\nexport const DIJKSTRAS_LABEL = \"Dijkstra's\";\nexport const BFS_LABEL = \"BFS\";\nexport const DFS_LABEL = \"DFS\";\nexport const ASTAR_LABEL = \"A*\";\nexport const GREEDY_BEST_FIRST_LABEL = \"Greedy Best First Search\";\n\nclass NavBar extends Component {\n  render() {\n    return (\n      <Navbar collapseOnSelect expand=\"lg\" bg=\"light\" variant=\"light\">\n        <Navbar.Brand href=\"#home\">Pathfinding Visualizer</Navbar.Brand>\n        <Navbar.Toggle aria-controls=\"responsive-navbar-nav\" />\n        <Navbar.Collapse id=\"responsive-navbar-nav\">\n          <Nav className=\"mr-auto\">\n            <NavDropdown title=\"Algorithms\" id=\"collasible-nav-dropdown\">\n              <NavDropdown.Item\n                href=\"#action/3.1\"\n                onSelect={() => this.props.setAlgorithm(DIJKSTRAS_LABEL)}\n              >\n                Dijkstra's\n              </NavDropdown.Item>\n              <NavDropdown.Item\n                href=\"#action/3.2\"\n                onSelect={() => this.props.setAlgorithm(BFS_LABEL)}\n              >\n                Breadth First Search\n              </NavDropdown.Item>\n              <NavDropdown.Item\n                href=\"#action/3.3\"\n                onSelect={() => this.props.setAlgorithm(DFS_LABEL)}\n              >\n                Depth First Search\n              </NavDropdown.Item>\n              <NavDropdown.Item\n                href=\"#action/3.4\"\n                onSelect={() => this.props.setAlgorithm(GREEDY_BEST_FIRST_LABEL)}\n              >\n                Greedy Best First Search\n              </NavDropdown.Item>\n              <NavDropdown.Item\n                href=\"#action/3.5\"\n                onSelect={() => this.props.setAlgorithm(ASTAR_LABEL)}\n              >\n                A*\n              </NavDropdown.Item>\n            </NavDropdown>\n            <span>\n              <Button variant=\"info\" onClick={this.props.onVisualize}>\n                {`Visualize ${this.props.selectedAlgorithm}`}\n              </Button>{\" \"}\n            </span>\n            <Button variant=\"light\" onClick={this.props.onClearPath}>\n              Clear Path\n            </Button>{\" \"}\n            <Button variant=\"light\" onClick={this.props.onClearWalls}>\n              Clear Walls\n            </Button>{\" \"}\n            <Button variant=\"light\" onClick={this.props.onReset}>\n              Reset\n            </Button>\n          </Nav>\n        </Navbar.Collapse>\n      </Navbar>\n    );\n  }\n}\n\nexport default NavBar;\n","import React, { Component } from \"react\";\nimport \"./legend.css\";\n\nclass Legend extends Component {\n  render() {\n    return (\n      <div className=\"legend\">\n        <span className=\"legend-item block black\"></span>\n        <span className=\"legend-item\">Wall</span>\n        <span className=\"legend-item block green\"></span>\n        <span className=\"legend-item\">Visited node</span>\n        <span className=\"legend-item block yellow\"></span>\n        <span className=\"legend-item\">Path</span>\n        <span>\n          <span id=\"startSymbol\" className=\"legend-item\"></span>\n          <span className=\"legend-item\">Start node</span>\n        </span>\n        <span>\n          <svg\n            width=\"2em\"\n            height=\"2em\"\n            viewBox=\"0 0 16 16\"\n            class=\"bi bi-asterisk ml-2\"\n            fill=\"currentColor\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n            style={{ width: \"26px\", height: \"26px\" }}\n          >\n            <path\n              fill-rule=\"evenodd\"\n              d=\"M8 0a1 1 0 0 1 1 1v5.268l4.562-2.634a1 1 0 1 1 1 1.732L10 8l4.562 2.634a1 1 0 1 1-1 1.732L9 9.732V15a1 1 0 1 1-2 0V9.732l-4.562 2.634a1 1 0 1 1-1-1.732L6 8 1.438 5.366a1 1 0 0 1 1-1.732L7 6.268V1a1 1 0 0 1 1-1z\"\n            />\n          </svg>\n          <span className=\"legend-item\">End node</span>\n        </span>\n\n        <span className=\"legend-item time\">\n          <svg\n            width=\"1em\"\n            height=\"1em\"\n            viewBox=\"0 0 16 16\"\n            class=\"bi bi-clock m-2\"\n            fill=\"currentColor\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n          >\n            <path\n              fill-rule=\"evenodd\"\n              d=\"M8 15A7 7 0 1 0 8 1a7 7 0 0 0 0 14zm8-7A8 8 0 1 1 0 8a8 8 0 0 1 16 0z\"\n            />\n            <path\n              fill-rule=\"evenodd\"\n              d=\"M7.5 3a.5.5 0 0 1 .5.5v5.21l3.248 1.856a.5.5 0 0 1-.496.868l-3.5-2A.5.5 0 0 1 7 9V3.5a.5.5 0 0 1 .5-.5z\"\n            />\n          </svg>\n          <span\n            className=\"legend-item time\"\n            key={this.props.legend.timeTaken}\n          >{`${this.props.legend.timeTaken} ms to find path`}</span>\n        </span>\n      </div>\n    );\n  }\n}\n\nexport default Legend;\n","import React, { Component } from \"react\";\nimport \"./node.css\";\n\nclass Node extends Component {\n  getClasses() {\n    let classes = \"node \";\n    const {\n      isStart,\n      isEnd,\n      isVisited,\n      isWall,\n      isPath,\n      isAnimating,\n    } = this.props.node;\n\n    classes += isStart\n      ? \"start\"\n      : isEnd\n      ? \"end\"\n      : isWall\n      ? \"wall\"\n      : // : isVisited\n        // ? \"visited\"\n        // : isPath\n        // ? \"path\"\n        \"\";\n\n    // if not currently animating nodes, keep nodes stagnant colours\n    if (!isAnimating) {\n      if (isPath) {\n        classes = \"path \" + classes;\n      } else if (isVisited) {\n        classes = \"visited \" + classes;\n      }\n    }\n\n    return classes;\n  }\n\n  render() {\n    const { col, row, isStart, isEnd } = this.props.node;\n\n    // if node is start/end, render specific symbol on top of the node\n    let startEndNode;\n\n    if (isStart) {\n      startEndNode = (\n        <div\n          className=\"startWrap\"\n          onMouseDown={() => this.props.onMouseDown(col, row)}\n          onMouseEnter={() => this.props.onMouseEnter(col, row)}\n          onMouseUp={() => this.props.onMouseUp()}\n        ></div>\n      );\n    } else if (isEnd) {\n      startEndNode = (\n        // <div\n        //   className=\"endWrap\"\n        //   onMouseDown={() => this.props.onMouseDown(col, row)}\n        //   onMouseEnter={() => this.props.onMouseEnter(col, row)}\n        //   onMouseUp={() => this.props.onMouseUp()}\n        // ></div>\n        <svg\n          width=\"1em\"\n          height=\"1em\"\n          viewBox=\"0 0 16 16\"\n          class=\"bi bi-asterisk \"\n          style={{\n            width: \"24px\",\n            height: \"24px\",\n            display: \"block\",\n            cursor: \"pointer\",\n            position: \"absolute\",\n            marginLeft: \"2px\",\n            marginTop: \"2px\",\n          }}\n          fill=\"currentColor\"\n          xmlns=\"http://www.w3.org/2000/svg\"\n          onMouseDown={() => this.props.onMouseDown(col, row)}\n          onMouseEnter={() => this.props.onMouseEnter(col, row)}\n          onMouseUp={() => this.props.onMouseUp()}\n        >\n          <path\n            fill-rule=\"evenodd\"\n            d=\"M8 0a1 1 0 0 1 1 1v5.268l4.562-2.634a1 1 0 1 1 1 1.732L10 8l4.562 2.634a1 1 0 1 1-1 1.732L9 9.732V15a1 1 0 1 1-2 0V9.732l-4.562 2.634a1 1 0 1 1-1-1.732L6 8 1.438 5.366a1 1 0 0 1 1-1.732L7 6.268V1a1 1 0 0 1 1-1z\"\n          />\n        </svg>\n      );\n    }\n\n    return (\n      <div className=\"wrap\">\n        {startEndNode}\n        <div\n          onMouseDown={() => this.props.onMouseDown(col, row)}\n          onMouseEnter={() => this.props.onMouseEnter(col, row)}\n          onMouseUp={() => this.props.onMouseUp()}\n          className={this.getClasses()}\n          id={`node ${col} ${row}`}\n        ></div>\n      </div>\n    );\n  }\n}\n\nexport default Node;\n","export default class PriorityQueue {\n  constructor(scoreFunction) {\n    this.heap = [null];\n    this.scoreFunction = scoreFunction;\n  }\n\n  /**\n   * pushes value into priority queue\n   * @param {*} value \n   */\n  push(value) {\n    this.heap.push(value);\n    this.heapifyUp(this.heap.length - 1);\n  }\n\n  /**\n   * returns and removes minimum value in priority queue\n   */\n  pop() {\n    const min = this.heap[1];\n    this.heap[1] = this.heap[this.heap.length - 1];\n    this.heap.pop();\n    this.heapifyDown(1);\n    return min;\n  }\n\n  /**\n   * returns true if priority queue is empty\n   */\n  isEmpty() {\n    return this.heap.length === 1;\n  }\n\n  /**\n   * returns minimum value without removing it from priority queue\n   */\n  peek() {\n    const min = this.heap[1];\n    return min;\n  }\n\n  /**\n   * returns index of the left child of element at given index\n   * @param {*} idx \n   */\n  leftChild(idx) {\n    return 2 * idx;\n  }\n\n  /**\n   * returns index of right child of element at given index\n   * @param {*} idx \n   */\n  rightChild(idx) {\n    return 2 * idx + 1;\n  }\n\n  /**\n   * returns index of parent of element at given index\n   * @param {*} idx \n   */\n  parent(idx) {\n    return Math.floor(idx / 2);\n  }\n\n  /**\n   * returns true if element at given index has a child\n   * @param {*} idx \n   */\n  hasAChild(idx) {\n    return this.leftChild(idx) < this.heap.length;\n  }\n\n  /**\n   * returns the child of the current index with the lowest score\n   * assume function will be called only if currIdx has a child\n   * @param {*} currIdx\n   */\n  minChild(currIdx) {\n    const leftIdx = this.leftChild(currIdx);\n    const rightIdx = this.rightChild(currIdx);\n\n    // if no right child, then return left child\n    if (rightIdx >= this.heap.length) {\n      return leftIdx;\n    }\n\n    const leftScore = this.scoreFunction(this.heap[leftIdx]);\n    const rightScore = this.scoreFunction(this.heap[rightIdx]);\n\n    if (leftScore < rightScore) {\n      return leftIdx;\n    }\n\n    return rightIdx;\n  }\n\n  /**\n   * restores heap order by swapping down from given index until all children \n   * are larger than parents.\n   * @param {*} currIdx \n   */\n  heapifyDown(currIdx) {\n    if (this.hasAChild(currIdx)) {\n      const minChildIdx = this.minChild(currIdx);\n\n      const childScore = this.scoreFunction(this.heap[minChildIdx]);\n      const currScore = this.scoreFunction(this.heap[currIdx]);\n\n      if (currScore > childScore) {\n        this.swap(currIdx, minChildIdx);\n        this.heapifyDown(minChildIdx);\n      }\n    }\n  }\n\n  /**\n   * restores heap order by swapping up from given index until all children \n   * are larger than parents\n   * @param {*} currIdx \n   */\n  heapifyUp(currIdx) {\n    if (currIdx === 1) {\n      return;\n    }\n\n    const parentIdx = this.parent(currIdx);\n\n    const currScore = this.scoreFunction(this.heap[currIdx]);\n    const parentScore = this.scoreFunction(this.heap[parentIdx]);\n\n    if (currScore < parentScore) {\n      this.swap(currIdx, parentIdx);\n      this.heapifyUp(parentIdx);\n    }\n  }\n\n  /**\n   * swap elements at idxA and idxB in the priority queue\n   * @param {*} idxA \n   * @param {*} idxB \n   */\n  swap(idxA, idxB) {\n    let temp = this.heap[idxA];\n    this.heap[idxA] = this.heap[idxB];\n    this.heap[idxB] = temp;\n  }\n}\n","import PriorityQueue from \"./PriorityQueue\";\n\nexport function dijkstras(graph, startNode, endNode) {\n  // track visited nodes in order\n  let visited = [];\n\n  let pq = new PriorityQueue(function (node) {\n    return node.distance;\n  });\n\n  // initialize source\n  startNode.distance = 0;\n  pq.push(startNode);\n  // start at source node\n\n  while (!pq.isEmpty()) {\n    let currNode = pq.pop();\n    // console.log(currNode);\n\n    const { col, row } = currNode;\n\n    currNode.isVisited = true;\n    visited.push(currNode);\n    // if current node is end node, we are done searching\n    if (currNode === endNode) {\n      return visited;\n    }\n\n    // for each unvisited neighbour:\n    let neighbours = getUnvisitedNeighbours(graph, currNode);\n    for (let neighbour of neighbours) {\n      // update distance from start node and predecessor\n      if (currNode.distance + 1 < neighbour.distance) {\n        neighbour.distance = currNode.distance + 1;\n        neighbour.predecessor = currNode;\n        pq.push(neighbour);\n      }\n    }\n  }\n\n  return visited;\n}\n\n/*\nreturns shortest path from startNode to endNode\n*/\nexport function getShortestPath(endNode) {\n  const path = [];\n\n  // If there is no path to the endNode i.e the endNode does not have a predecessor\n  if (endNode.predecessor === null) {\n    return [];\n  }\n\n  let currNode = endNode;\n  while (currNode !== null) {\n    currNode.isPath = true;\n    path.push(currNode);\n    currNode = currNode.predecessor;\n  }\n\n  return path.reverse();\n}\n\n/*\nreturns unvisited, non-wall neighbours (N, E, S, W) of given node \n*/\nexport function getUnvisitedNeighbours(graph, node) {\n  const neighbours = [];\n  const { col, row } = node;\n  if (row > 0) neighbours.push(graph[col][row - 1]);\n  if (col < graph.length - 1) neighbours.push(graph[col + 1][row]);\n  if (row < graph[0].length - 1) neighbours.push(graph[col][row + 1]);\n  if (col > 0) neighbours.push(graph[col - 1][row]);\n\n  return neighbours.filter((n) => !n.isVisited && !n.isWall);\n}\n","export default class Queue {\n  constructor() {\n    this.elems = [];\n    this.first = 0; // index of first element in array\n    this.size = 0; // number of items in array\n  }\n\n  /**\n   * pushes given object to end of queue\n   * @param {*} elem\n   */\n  enqueue(elem) {\n    this.elems.push(elem);\n    this.size++;\n  }\n\n  /**\n   * returns and removes object at front of queue\n   * resizes array downward when elements can fit into the first\n   * 0...k-1 indices of the array to achieve O(1) amortized runtime\n   *\n   * assume function will not be called on an empty queue\n   */\n  dequeue() {\n    const front = this.elems[this.first];\n    this.elems[this.first] = null;\n    this.first++;\n    this.size--;\n\n    if (!this.isEmpty() && this.size === this.first) {\n      this.elems.splice(0, this.first);\n      this.first = 0;\n    }\n\n    return front;\n  }\n\n  /**\n   * returns whether queue is empty\n   */\n  isEmpty() {\n    return this.size === 0;\n  }\n\n  /**\n   * returns object at front of queue without removing it\n   */\n  front() {\n    return this.elems[this.first];\n  }\n\n}\n","import Queue from \"./Queue\";\nimport { getUnvisitedNeighbours } from \"./dijkstras\";\n\nexport function bfs(graph, startNode, endNode) {\n  const q = new Queue();\n  const visited = [];\n\n  q.enqueue(startNode);\n  visited.push(startNode);\n  startNode.isVisited = true;\n\n  while (!q.isEmpty()) {\n    let currNode = q.dequeue();\n\n    let neighbours = getUnvisitedNeighbours(graph, currNode);\n    for (let neighbour of neighbours) {\n      neighbour.isVisited = true;\n      visited.push(neighbour);\n      neighbour.predecessor = currNode;\n\n      if (neighbour === endNode) {\n        return visited;\n      }\n\n      q.enqueue(neighbour);\n    }\n  }\n\n  return visited;\n}\n","export default class Stack {\n  constructor() {\n    this.elems = [];\n  }\n\n  /**\n   * pushes elem to top of stack\n   * @param {*} elem \n   */\n  push(elem) {\n    this.elems.push(elem);\n  }\n\n  /**\n   * returns and removes elem on top of stack\n   */\n  pop() {\n    return this.elems.pop();\n  }\n\n  /**\n   * returns true if stack is empty\n   */\n  isEmpty() {\n    return this.elems.length === 0;\n  }\n\n  /**\n   * returns elem on top of stack without removing it\n   */\n  peek() {\n    return this.elems[this.elems.length - 1];\n  }\n}\n","import Stack from \"./Stack\";\nimport { getUnvisitedNeighbours } from \"./dijkstras\";\n\nexport function dfs(graph, startNode, endNode) {\n  const stack = new Stack();\n  const visited = [];\n\n  stack.push(startNode);\n  visited.push(startNode);\n  startNode.isVisited = true;\n\n  while (!stack.isEmpty()) {\n    let currNode = stack.pop();\n\n    let neighbours = getUnvisitedNeighbours(graph, currNode);\n    for (let neighbour of neighbours) {\n      neighbour.isVisited = true;\n      visited.push(neighbour);\n      neighbour.predecessor = currNode;\n\n      if (neighbour === endNode) {\n        return visited;\n      }\n\n      stack.push(neighbour);\n    }\n  }\n\n  return visited;\n}\n","import PriorityQueue from \"./PriorityQueue\";\nimport { getUnvisitedNeighbours } from \"./dijkstras\";\n\nexport function aStar(graph, startNode, endNode) {\n  const openSet = new PriorityQueue(function (node) {\n    return node.f;\n  });\n\n  const visited = []; // closed set\n\n  // initialize open set\n  startNode.f = 0;\n  startNode.distance = 0;\n  openSet.push(startNode);\n\n  while (!openSet.isEmpty()) {\n    // find node with least f on open set\n    let currNode = openSet.pop();\n\n    currNode.isVisited = true;\n    visited.push(currNode);\n\n    if (currNode === endNode) {\n      return visited;\n    }\n\n    let neighbours = getUnvisitedNeighbours(graph, currNode);\n    for (let neighbour of neighbours) {\n      if (currNode.distance + 1 < neighbour.distance) {\n        neighbour.predecessor = currNode;\n        neighbour.distance = currNode.distance + 1;\n\n        // calculate manhattan distance heuristic for neighbour\n        let h =\n          Math.abs(neighbour.col - endNode.col) +\n          Math.abs(neighbour.row - endNode.row);\n        let g = neighbour.distance;\n        neighbour.f = g + h;\n\n        openSet.push(neighbour);\n      }\n    }\n  }\n\n  return visited;\n}\n","import PriorityQueue from \"./PriorityQueue\";\nimport { getUnvisitedNeighbours } from \"./dijkstras\";\n\nexport function greedyBestFirstSearch(graph, startNode, endNode) {\n    const openSet = new PriorityQueue(function (node) {\n        return node.f;\n      });\n    \n      const visited = []; // closed set\n    \n      // initialize open set\n      startNode.f = 0;\n      startNode.distance = 0;\n      openSet.push(startNode);\n    \n      while (!openSet.isEmpty()) {\n        // find node with least f on open set\n        let currNode = openSet.pop();\n    \n        currNode.isVisited = true;\n        visited.push(currNode);\n    \n        if (currNode === endNode) {\n          return visited;\n        }\n    \n        let neighbours = getUnvisitedNeighbours(graph, currNode);\n        for (let neighbour of neighbours) {\n          if (currNode.distance + 1 < neighbour.distance) {\n            neighbour.predecessor = currNode;\n            neighbour.distance = currNode.distance + 1;\n    \n            // calculate manhattan distance heuristic for neighbour\n            let h =\n              Math.abs(neighbour.col - endNode.col) +\n              Math.abs(neighbour.row - endNode.row);\n            neighbour.f = h;\n    \n            openSet.push(neighbour);\n          }\n        }\n      }\n    \n      return visited;\n}","import React, { Component } from \"react\";\nimport NavBar from \"./components/navbar\";\nimport {\n  DIJKSTRAS_LABEL,\n  BFS_LABEL,\n  DFS_LABEL,\n  ASTAR_LABEL,\n  GREEDY_BEST_FIRST_LABEL,\n} from \"./components/navbar\";\nimport Legend from \"./components/legend\";\nimport Node from \"./components/node.jsx\";\nimport \"./PathfindingVisualizer.css\";\nimport { dijkstras, getShortestPath } from \"./algorithms/dijkstras\";\nimport { bfs } from \"./algorithms/bfs\";\nimport { dfs } from \"./algorithms/dfs\";\nimport { aStar } from \"./algorithms/aStar\";\nimport { greedyBestFirstSearch } from \"./algorithms/greedyBestFirstSearch\";\n\nconst START_NODE_X = 12;\nconst START_NODE_Y = 10;\nconst END_NODE_X = 30;\nconst END_NODE_Y = 10;\nconst NUM_COLS = 43;\nconst NUM_ROWS = 21;\nconst TIME = 0;\n\nclass PathfindingVisualizer extends Component {\n  state = {\n    nodes: [],\n    start: { x: START_NODE_X, y: START_NODE_Y },\n    end: { x: END_NODE_X, y: END_NODE_Y },\n    mouseIsPressed: false,\n    startIsPressed: false,\n    endIsPressed: false,\n    selectedAlgorithm: \"\",\n    legend: {\n      timeTaken: TIME.toFixed(3),\n      algorithmMessage: \"\",\n    },\n    isAnimating: false,\n  };\n\n  componentDidMount() {\n    const nodes = this.getInitialGraph();\n    this.setState({ nodes });\n  }\n\n  /**\n   * animates traversal of given algorithm on current graph state\n   * @param {*} algorithm algorithm to visualize\n   */\n  visualize(algorithm) {\n    this.resetNodesToUnvisited();\n\n    // deep copy of the state's nodes\n    const graph = this.state.nodes.map((col) => {\n      return col.map((node) => {\n        let newNode = {};\n        for (let key in node) {\n          newNode[key] = node[key];\n        }\n        return newNode;\n      });\n    });\n\n    const { start, end } = this.state;\n    const startNode = graph[start.x][start.y];\n    const endNode = graph[end.x][end.y];\n    const startTime = performance.now();\n\n    const visitedNodes = algorithm(graph, startNode, endNode);\n\n    // get time allotted for searching animation to finish\n    const endTime = performance.now();\n    const time = (endTime - startTime).toFixed(3);\n\n    // start animation of traversal\n    this.setState({ isAnimating: true });\n    // for each visited node:\n    // one extra iteration to animate path\n    for (let i = 0; i <= visitedNodes.length; i++) {\n      // if on last iteration, animate path\n      // timeout proportional to iteration number so path animates after visited nodes\n      if (i === visitedNodes.length) {\n        setTimeout(() => {\n          const shortestPath = getShortestPath(endNode);\n          this.animatePath(shortestPath);\n\n          setTimeout(() => {\n            this.setState({ nodes: graph, isAnimating: false });\n\n            this.setState({ legend: { timeTaken: time } });\n          }, 30 * shortestPath.length + 1200); /** delay until last iteration of path animation\n                                                plus amount of seconds to animate path node */\n        }, 15 * i + 500);\n\n        return;\n      }\n\n      let currNode = visitedNodes[i];\n      const { col, row } = currNode;\n      // animate each node to change colour one after another\n      // timeout based on position in list so that\n      // each node should only changes colour after the previously visited one has changed colour\n      setTimeout(() => {\n        document.getElementById(`node ${col} ${row}`).className +=\n          \" visited-animation\";\n      }, 15 * i);\n    }\n  }\n\n  /**\n   * animates the given shortest path nodes in order\n   * @param {*} shortestPath\n   */\n  animatePath(shortestPath) {\n    for (let i = 0; i < shortestPath.length; i++) {\n      let currNode = shortestPath[i];\n      const { col, row } = currNode;\n      setTimeout(() => {\n        document.getElementById(`node ${col} ${row}`).className +=\n          \" path-animation\";\n      }, 30 * i);\n    }\n  }\n\n  handleMouseDown = (x, y) => {\n    const graph = [...this.state.nodes];\n    const currNode = graph[x][y];\n    if (!currNode.isStart && !currNode.isEnd) {\n      this.toggleWall(currNode, graph);\n      this.setState({ mouseIsPressed: true });\n    } else {\n      if (currNode.isStart) {\n        this.setState({ mouseIsPressed: true, startIsPressed: true });\n      } else {\n        this.setState({ mouseIsPressed: true, endIsPressed: true });\n      }\n    }\n  };\n\n  handleMouseEnter = (x, y) => {\n    if (!this.state.mouseIsPressed) {\n      return;\n    }\n\n    const graph = [...this.state.nodes];\n    const currNode = graph[x][y];\n\n    if (this.state.startIsPressed) {\n      this.changeStartNode(currNode, graph);\n      return;\n    } else if (this.state.endIsPressed) {\n      this.changeEndNode(currNode, graph);\n      return;\n    }\n\n    if (!currNode.isStart && !currNode.isEnd) {\n      this.toggleWall(currNode, graph);\n    }\n  };\n\n  handleMouseUp = () => {\n    // make sure that where start and end node are placed is not ON a wall\n    const nodes = [...this.state.nodes];\n    const { start, end } = this.state;\n    nodes[start.x][start.y].isWall = false;\n    nodes[end.x][end.y].isWall = false;\n\n    this.setState({\n      nodes,\n      mouseIsPressed: false,\n      startIsPressed: false,\n      endIsPressed: false,\n    });\n  };\n\n  setSelectedAlgorithm = (algorithm) => {\n    this.setState({ selectedAlgorithm: algorithm });\n  };\n\n  handleVisualize = () => {\n    const { selectedAlgorithm } = this.state;\n\n    switch (selectedAlgorithm) {\n      case DIJKSTRAS_LABEL:\n        this.visualize(dijkstras);\n        break;\n      case BFS_LABEL:\n        this.visualize(bfs);\n        break;\n      case DFS_LABEL:\n        this.visualize(dfs);\n        break;\n      case ASTAR_LABEL:\n        this.visualize(aStar);\n        break;\n      case GREEDY_BEST_FIRST_LABEL:\n        this.visualize(greedyBestFirstSearch);\n        break;\n      default:\n        alert(\"Select an algorithm to visualize!\");\n        return;\n    }\n  };\n\n  /**\n   * resets graph to the intial graph\n   */\n  handleReset = () => {\n    const nodes = this.getInitialGraph();\n    this.setState({\n      nodes,\n      start: { x: START_NODE_X, y: START_NODE_Y },\n      end: { x: END_NODE_X, y: END_NODE_Y },\n    });\n  };\n\n  /**\n   * clears all walls from graph without moving start and end nodes\n   */\n  clearWalls = () => {\n    const graph = [...this.state.nodes];\n    for (let x = 0; x < NUM_COLS; x++) {\n      for (let y = 0; y < NUM_ROWS; y++) {\n        let node = graph[x][y];\n        node.isWall = false;\n      }\n    }\n\n    this.setState({ nodes: graph });\n  };\n\n  render() {\n    return (\n      <React.Fragment>\n        <NavBar\n          setAlgorithm={this.setSelectedAlgorithm}\n          selectedAlgorithm={this.state.selectedAlgorithm}\n          onVisualize={this.handleVisualize}\n          onReset={this.handleReset}\n          onClearPath={this.resetNodesToUnvisited}\n          onClearWalls={this.clearWalls}\n        />\n        <Legend legend={this.state.legend} />\n        <div key={new Date()} className=\"grid\">\n          {this.state.nodes.map((col, colIdx) => {\n            return (\n              <div key={colIdx}>\n                {col.map((node, rowIdx) => (\n                  <Node\n                    key={rowIdx}\n                    onMouseDown={this.handleMouseDown}\n                    onMouseEnter={this.handleMouseEnter}\n                    onMouseUp={this.handleMouseUp}\n                    isAnimating={this.state.isAnimating}\n                    node={node}\n                  />\n                ))}\n              </div>\n            );\n          })}\n        </div>\n      </React.Fragment>\n    );\n  }\n\n  /**\n   * \ttoggles the given node at x,y on the graph as/not as a wall\n   * @param {*} currNode\n   * @param {*} graph\n   */\n  toggleWall(currNode, graph) {\n    const newNode = {\n      ...currNode,\n      isWall: !currNode.isWall,\n    };\n\n    graph[currNode.col][currNode.row] = newNode;\n    this.setState({ nodes: graph });\n  }\n\n  /**\n   * sets given node as the end node\n   * @param {*} currNode\n   * @param {*} graph\n   */\n  changeEndNode(currNode, graph) {\n    const { col, row } = currNode;\n    const { x, y } = this.state.end;\n    graph[x][y].isEnd = false;\n    currNode.isEnd = true;\n    // currNode.isWall = false;\n    this.setState({ nodes: graph, end: { x: col, y: row } });\n  }\n\n  /**\n   * sets given node as the start node\n   * @param {*} currNode\n   * @param {*} graph\n   */\n  changeStartNode(currNode, graph) {\n    const { col, row } = currNode;\n    const { x, y } = this.state.start;\n    graph[x][y].isStart = false;\n    currNode.isStart = true;\n    // currNode.isWall = false;\n    this.setState({ nodes: graph, start: { x: col, y: row } });\n  }\n\n  /**\n   * resets state's nodes to before dijkstra's was called\n   */\n  resetNodesToUnvisited = () => {\n    const graph = [...this.state.nodes];\n    for (let x = 0; x < NUM_COLS; x++) {\n      for (let y = 0; y < NUM_ROWS; y++) {\n        let node = graph[x][y];\n        node.isVisited = false;\n        node.isPath = false;\n        node.distance = Infinity;\n        node.predecessor = null;\n      }\n    }\n\n    this.setState({ nodes: graph });\n  };\n\n  /**\n   * returns initial graph with no walls toggled or visited nodes\n   */\n  getInitialGraph() {\n    const nodes = [];\n\n    for (let col = 0; col < NUM_COLS; col++) {\n      const currCol = [];\n      for (let row = 0; row < NUM_ROWS; row++) {\n        const currNode = {\n          col,\n          row,\n          isStart: col === START_NODE_X && row === START_NODE_Y,\n          isEnd: col === END_NODE_X && row === END_NODE_Y,\n          isVisited: false,\n          isWall: false,\n          isPath: false,\n          distance: Infinity,\n          f: Infinity,\n          predecessor: null,\n        };\n        currCol.push(currNode);\n      }\n      nodes.push(currCol);\n    }\n    return nodes;\n  }\n}\n\nexport default PathfindingVisualizer;\n","import \"bootstrap/dist/css/bootstrap.min.css\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport PathfindingVisualizer from \"./PathfindingVisualizer\";\n\nReactDOM.render(<PathfindingVisualizer />, document.getElementById(\"root\"));\n"],"sourceRoot":""}